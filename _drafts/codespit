FIXED NUMBER
복잡한 것을  다룰 수 있는가? 
프로그램?
메모리에 적재 되고 나서 부터 프로그램
랭기지 코드 - 린팅
머신 랭기징 - 컴파일

스크립트 언어 - 런타임에 컴파일하게됨
에러 찾기가 힘들어 진다.
스테틱 타임 - 레이어별로 나눔(베이스, 확장, 사용)

복잡성을 정복 - 격리(일을 맞김, 여러 요소로 나누면 ex))
코드 한줄을 짜더라도 어디까지 영향을 미추고  

리터럴 - 어떤 것을 표현할때 가장 작은 단위 ("37"은 리터럴이다. "15 + 12"는 아니다.)

더 깊이, 왜 그런지를 생각해야 API만 쓰다가 끝나지 않는다.

statements - 어떻게 실행되는 지는 가르쳐주는 흰트
식 - 값의 확장된 표현, 결과적으로 단위와 값에 속하게된다. 

참조형
let b = a 

알아야 할것을 확실히 알아야 한다.
컴공은 사실상 다 알아야함
하지만 재현 가능, 공리가 없어
코드를 어디까지 설명할 수 있는가?

할당은 LR이 아니다.
수학의 영향을 받아서임
수학의 영향을 받는게 많음
5 / 2 * 3 % 4 ? 암산 가능? 
사소한 수식이라도 괄호 치기, 혹은 함수로 바꿀수 있다면, 바꾸기

의도를 표현 - do while, while, if, switch 
제어문을 어떻게 쓰고 어떤 문을 어떻게 쓰는지로 의도를 표현 할수있다. 변수이름이 중요한게 아니다.
제어문은 힌트다.
괄호
1. 산술 연산의 우선 순위
2. 제어문에 들어가는 형식 기호
3. 함수 호출시 호출하는 연산

문자 하나당 가지는 의미 세미콜론도 여러가지 의미가 있다.

if 문 - 선택적인 실행(optional)
if A else B 문 - A,B 중하나가 확정적으로 수행(mandatory), 선택지

나무위에 산다 - 천적x, 뱀말고 뱀모양인거가 위협, 떨어지면 위험 - 신속하게
2지 선다가 뇌가 인식하기가 좋음
모든 코드는 사람에게 맞게
본인만의 세계를 구축하자 


레이블, 레이블 스코프(블록 x, 함수 o), 레이블이 가르킬수 있는거 레이블 레인지
이터레이션 셋, 레이블 셋(레이블이 가르키고 있는 영역, break가 되려면 뒤에 레이블이 있어야함, 없으면 에러)
이전의 언어는 위아래로 점프가 가능하지만, 요즘 언어는 아래로만 가능

예외 - 밑으로 점프하는 경우임!!!!!
abc: {
    log('a');
    break abc;//위로 갈거 같지만, 아래로감, 터보C이후에 나온 언어들은 이렇게 나옴  
    log('b');
}
log('c');

흐름 제어를 하지

변수의 중요한 요소(일반론)
라이프 사이클 : 특정 시점에 생겼다가 사라짐
접근 제어 : 스코프(접근 권한)을 둠

js
스코프 - 라이프 사이클이라고 부름


함수의 인자, 블록 스코프, 지역 변수, 맴버 변수
-> 자유 변수(자기를 기준으로 자기가 알 수 없는 것ex(함수의 ㅕㅇ우는 지역변수와 인자를 제외하면 자유 변수)), 
클로저(자유변수가 사용 될수 있는 공간)

let a = 3
const f = () =? {
    log(a)
}
a는 f에게 자유 변수가 된다.
쉐도잉 - 자유변수와 자신의 변수의 이름이 같으면 자신의 변수를 사용

k1:{
    let a = 3
    const f = () => {
        let a = 5;
        k:{
            break k1;//에러 스코프 안에 있는 내용만 
            log(22);
        }
    }
}

break, continue(goto 같으면)
이터레이션 셋 - 익명이 가능, 브레이크, 컨티뉴 둘다 가능 
레이블 셋 - 브레이크만 함 

스위치 레이블 블록 - 문이 아니다.
break;가 가능한 이유는 익명레이블을 만들기 때문이다.
js는 컴파일 타임이 없기 때문에 한줄씩 진행
때문에 js switch의 경우는 모든 case를 체크한다. 그리고 case에 
때문에 2가지가 가능하다.
1. 조건이 한정적이고 값이 다양한경우
2. 값이 한정적이고 조건이 다양한경우 
case 에 조건 넣기
-> java의 경우는 불가 - 상수만 가능

case에 식으로 할때는 복잡해 질수 있다.

레이블은 흐름 제어의 기본이다.
조건문과 반복문 이용해서 명시적으로 사용함

if문 
if else문만 존재
else if는
else{
    if
}
로생각

언어에서 파서가 허용한다면
else switch{

}

else for{

}
같은것도 가능

if else는 후방 결합
else if는 되도록 사용하지 하지 말자 else뒤에 괄호를 쓰자(연산자 우선 순위를 괄호를 사용하는거 처럼)
습관으로 복잡성을 줄이자. 
else <statements> <statements>
병렬일때는 조심하라!!!!! 컴파일 

if{

}else if{

}
는 병행이 쓰면 안됨 스위처럼 쓸꺼면

if는 선택이지만 if else는 절대 실행해야함(mandatory)
if(c == 1){

}else{
    if(c == 2){

    }else ;//
}
수정에 대응이 잘된다. - 코드가 잘되어 있다면 그렇다.
정확한 의도에 맞춰서 코드를 짜야한다. 변화가 일어날 때 바꿀수 있음

switch문은 default가 무조건 반드시 예외가 있을수 있기때문이다.
else -> switch -> default가 있으니 mandatory가 가능

var a = 3;선언문은 식은 아니라 식이라면 대입됨
for(선언문 or ex; ex - truety; ex-for문의 마지막에 실행){

}
'', false, 0, undefind, null, NaN //falsy -> 예전에 조건문이 이것들이면 빨랐지만 지금은 같다.

for(;;;)는 무한루프. 가운데 식이 없으면 언어로 ture로 정의함 일반적으로 empty는 falsy다.

while(truethy){}은 식이 있어야한다.

한번은 실행하야하는경우 자바에서 레퍼런스
do{

}while(truethy);//세미콜론 붙여야함

while문과 do while문은 평가식에 있는 코드가 바디에 없다면 많은 경우 무한루프
while(act.method().c){
    other.action();
}
이라면 문제가 되므로 
a = act.method().c
while(a){
    other.action();
    a = act.method().c;//이러면 로그로 찍어볼 생각이 날것이다.
    //a값을 바꿔보는 테스트가 가능하다.
}
무조건 밖으로 빼야함

while문은 2줄이상 써야한다.

do <statements> while(<condition>)

for( of );
for( in );

인터페이스 : 사양에 맞는 값과 연결된 속성키의 셋
덕다이핑에서 나옴 - 런타임에 타입체크가 되지 않아서 사용
어떤 인터페이스를 만족(구현)한다면 그 인터페이스를 사용한다.
이런 인터페이스이스는 외울수 밖에 없음
const Test = class{
    test(str){
        return true;
    }
};

const test = new Test();




iterator interface
1. next라는 키를 갖고
2.
3.
4.

const iterator = {
    next(){
        return{
            done: true,//반복 가능 여부
            value : 1// 가져올수 있는 값
        };
    }
};
국산 자바스크립트 책은 안되에!!!!!! 역서를 보셈요 아니면 원서, 스펙문서를 같이보셈셈
완벽가이드 -> ES5는 완벽함

iterable interface
1. Sysmbol.iterator라는 키를 잦고
2. 값으로 인자를 받지 않고 

Sysmbol 프리미티브
const s = Sysmbol()

const iterable{
    //well knowned Sysmbol -> @@문자열로 대체가 가능하다.//
    //key가오고 괄호가 오면 :function이  생략됨
    [Sysmbol.iterator](){

    }
    //['@@iterator'] 근데 걍쓰지마라
}

왠만해서는 iterable, interface는 구현되어 있음
