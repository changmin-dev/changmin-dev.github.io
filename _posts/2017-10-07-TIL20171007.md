---
layout: post
title: 2017년 10월 7일 TIL
---
# 네트워크 
약자의 원래 이름과 왜 이런지 생각하기

## 패킷
패킷은 비트들의 묶음으로 중간 중간 라우터를 거쳐서 이동 한다.
패킷을 검사한다는 것은 `목적지가 어디인가?`를 알아 내는것  
프로파게이션은 빛의 속도 이므로 앞부분은 이미 도착 할 수 있다.
패킷의 앞부분이 도착하면 모든 부분이 올때까지 기다려야 한다.
`치킨` `ㅊ`이 온다고 가는게 아니라 `ㅊㅣㅋㅣ`이 와야 다음 목적지로 이동 한다.

## 인터넷 프로토콜 스택

|   이   름      | 주요 프로토콜     | |
| ----------    | ------------- | :----------: | 
| Application   | HTTP          | Process의 위치 
| Transport     | TCP, UDP      |
| Network       | IP            |
| Data Link     | Ethernet, WIFI|
| Physical      | Twisted Pair  |

라우터의 계층은 네트워크 까지만 존재한다.

|   이   름      | 주요 프로토콜   
| ----------    | --------- 
| Network       | IP       
| Data Link     | Ethernet, WIFI      
| Physical      | Twisted Pair     


## IP 주소
IP 인터넷 상의 각 컴퓨는 각각의 주소를 가지고 있다. 이를 IP주소라고 한다.
- 서버 : 고정된 ip주소 필요하다. 사람들이 찾아간다.윛기가 바뀐다면 찾기 힘듬
- 클라이언트 : 고정되지 않아도 된다.


## IPC를 위한 인터페이스 - 소켓 
소켓의 인덱싱(주소 역할)하는 것은 IP 주소와 포트번호(프로세스를 구별 하기 위함)
브라우저에서 입력하는 방법 www.naver.com
실제로는 www.naver.com:80 포트는 생략하면 80으로

### 어플리케이션끼리 같은 포트를 사용하는 이유?
서버 24시간 켜야하고, 주소가 일정해야 한다.
DNS는 주소만 해석한다. 포트가 다르면 포트에대한 처리를 해주어야함

## 트랜스포트 계층에서 기대 되는것
1. `데이타 무결성` - 이것만 가능!!!
2. 타이밍
3. 쓰루풋
4. 보안

## HTTP(Hyper Text Transfer Protocol)
하이퍼텍스트? - 택스트 인데 중간에 링크들이 있음  
HTTP는 대부분 TCP를 사용해서 TCP 커넥션이 필요하다.  
HTTP는 state less이다. 상태를 기억하지 않는다. 

### Non Persistent HTTP
TCP연결을 설정, 상대편이 설정하면 연결완료되면 HTTP통신을 한다. 이후 TCP연결을 해제 한다. 
1개 페이지가 여러개로 구성되어 있다면 계속 TCP부터 연결을 한다.

### Persistent HTTP 
연결을 재사용 한다. 클라이언트에서 정보를 다 받았다고 판단 했을때 TCP연결 해재한다. 실제는 보통 persistent를 사용한다.  

실제로는 한번에 리소스 여러개 요청을 보낸다.(파이프라인 방식)

## 소켓 프로그레밍
어플리케이션 프로그램 OS가 아니다. OS에서 제공하는 서비스를 사용 OS가 제공하는 인터페이스를 사용하는것이다.
TCP/UDP에 맞게 해당하는 소켓을 사용해서 데이터를 주고 받는다.

## 멀티 플랙싱과 디멀티 플랙싱
TCP에서는 세그먼트를 주고 받는다. 이는 어플리케이션 측 데이터에 TCP헤더가 추가된것이다.

### 멀티플랙싱 
Sender가 어플리케이션에서 전달된 다양한 데이터를 세그먼트로 만들어줌

### 디멀티 플랙싱 
Reciver가 세그먼트에 맞게 어플리케이션 계층에 데이터를 전달 

## Transfer layer의 Header
헤더의 여러필드가 있는데 그중에서 중요한 것은 소스와 데스트네이션의 포트번호이다.
클라이언트에서 소스는 자신의 포트이고 데스트네이션은 서버의 포트이다. 

### TCP의 경우 
TCP는 소켓을 구별한다. 소스, 데스네이션 각각의 아이피와 포트번호 4가지 중 하나라도 틀리면 다른 소켓이다.
TCP 연결지향 - 특정 연결에 대한 소켓을 만든다. 자원소모가 크다.
- 브로드 캐스트 : 각각 TCP연결을 한다.

### UDP의 경우 
UDP는 아무나 전달, 그냥 소켓으로 전달만함 
UDP는 신뢰성 보장을 하지 않는다. 하지만 트랜스포트에서 제공하는 것은 제공함

### UDP 헤더 필드
TCP에 비해 간단하다. 
소스포트 16비트 /목적지포트 16비트/ Length(멀티플랙싱, 디멀티 플랙싱에 사용) /체크섬
체크섬으로 에러 파악, 전송하지 않고 죽이는 식

## Transport에서 해주어야하는거 
멀티플랙싱과 에러채킹(에러가 발생하면 어플리케이션으로 가지 않는다.) 이는 UDP도 동일하다.

## Relable data tranfer protocol
TCP 4가지 특징중 가장 중요한건 릴라이어블 통신 환경은 사실 불안전하다.
1. 패킷의 유실
2. 패킷 에러

### 1.0 단순한 버전
에러와 유실이 없는 경우
- sender - 그냥 보냄
- reciver - 그냥 받음

### 2.0 에러가 있는 경우 
- Error 탐지 : 체크섬을 추가
- Feed back : 패킷을 받을때마다 Ack/Nak
(Negative Ack)를 보냄
- 재전송 : Nak받으면 재전송
Sender - 채크섬을 추가해서 보냄
Reciver - 체크섬확인 후 애러여부를 송신
피드백도 체크섬이 필요 피드백도 에러가 있을수 있다.
피드백이 망가진경우 다시 보낸다.

### 2.1 리시버가 중복데이터를 받으면 다시보낸건지 알수 없다. 
구별이 필요 -> 패킷에 번호를 붙인다. -> sequence number
sqeunce number 붙이는 법
header붙인다. - 부가정보니까
순서대로 붙인다. - 크기가 무한대가 됨 하지만 ㄴ헤더크기는 작을 수록 좋다. 최소한의 필드만 있어야 한다.
2개면 충분 - 0, 1 
0 받았으면 1기다림, 1받았으면 0기다림

### 2.2 NAK를 없앤 프로토콜
ACK에 가장 마지막에 받은 sequnce를 보낸다.
ACK번호가 이전과 같으면 애러

### 3.0 메세지 유실여부까지 추가
- 유실 - 유실되면 ACK가 안옴   
타이머를 넣는다. 
메세지를 보내고 타이머를 돌림  
얼마나 기다려야 하는가?

#### Trade off
시간이 짧음 - 실제 유실이 일어난경우 복구가 빠르다. 중복된걸 받을수 있다. - 지연됬는데도 유실로 처리되어서, 네트워크 오버헤드
시간이 길다 - 유실에 대한 반응이 늦다. 복구가 느림

### 성능 측정
Utilization - 전체 시간중에 sender가 메시지를 보내는 비율

## TCP Header
에러,손실처리, 나머지 기능을 = 처리하기 위한것을 처리

## 파이프라이닝 
실제는 하니씩 보내는게 아니라 한꺼번에 보낸다. 하나씩 보내는것 보다. Utilization이 높아짐
1. Go-Back-N
2. Selected Repeat

### GO-Back-N
- window : 한번에 얼마 만큼 보낼것인가?
- Ack(n) : n개까지 받았다.
- 타이머 : 패킷마다 타이머가 존재, 타임아웃되면 해당 패킷 포함해서 이후는 전부 재전송

```
1 2 3 4 5 x 7 8 9(6 이후 버림)
          6 7 8 9
```
샌더는 윈도우에 있는 패킷은 버퍼에 저장-리시버가 받았는지를 모름 

### Selected Repeat 
없어진 것만 재전송 
Ack(n) : n번 패킷을 받았다. 순서가 맞지 않아도 버퍼에 저장한다.
```
1234 -> 1 34(버퍼에 저장)
     <- 1, 3, 4 ACK
   2 -> 1234
     <- 2 ACK
```
모든 패킷에 타이머를? 윈도우의 크기가 크면 문제가 발생

### Sequnce number
최소한의 sequence number가 효율적이므로 재사용한다.
N을 윈도우 사이즈라고 한다면,
짧으면 N+1개 -> 0번이 유실되면 다음에 들어오는 0이 다음껀지 이번껀지 혼동 될수있다.
범위를 늘린다. -> 늘리면 비효율 ㅠ
`구별이 되는 최소의 범위를 찾기` 
약 2*N개(시스템마다 다를 수 있다.) 

## TCP에서 파이프 라인 구현
2가지 방법의 장점을 취합해서 구현한다.
윈도우 마다 타이머를 설정, GBN의 ACK를 사용 





