---
layout: post
title: 2018년 3월 30일 TIL
---

## Hash
해쉬 함수를 이용하여 키를 테이블에 저장하는 방법. 해쉬 함수 값을 인덱스로 이용한다.(index = hash(key), table[index] = key)    
평균 탐색, 삽입, 삭제 O(1) 최악의 경우는 O(n)

### Hash Collision(충돌)
두 개 이상의 키가 동일한 위치로 Hashing되는 경우(hash(key1) == hash(key2)) 이를 해결하기 위해 Chaining 혹은 Open Addressing을 사용한다.

### Chaining
동일한 장소로 Hashing되는 키들을 연결리스트로 저장하는 방법
삽입 : 해당 해시 인덱스의 맨 앞에 삽입 O(1), 중복 키 저장이 허용 되지 않고 중복 키가 입력이 될 수 있으면 O(리스트의 길이) 
검색 : 해당 해시 인덱스의 리스트에서 순차 검색 O(리스트 길이), 최악의 경우 모든 키가  
삭제 : 해당 해시 인덱스에서 키를 검색후 삭제, 키를 찾았다면 O(1)

### Open Addressing
충돌이 일어날 경우 인덱스를 다시 선정한다. 인덱스를 설정하는 방법은 다음과 같은 3가지가 있다.
1. Linear probing : hash(k), hash(k)+1, hash(k)+2, .. 순서로 검사하여 빈슬롯에 저장한다. 테이블의 끝에 도달하면 처음으로 가서 진행한다. 키에 의해서 채워진 연속된 슬롯을 primary cluster라고 부르르는데 이 cluster가 점점 커지게 되면 문제가 된다. 
2. Quadratic probing : Linear probing과 비슷하다. hash(k), hash(k)+1^2, hash(k)+2^2 순서로 진행한다. 
3. Double hashing : 서로 다른 두 해쉬 함수를 이용한다. 충돌이 발생하면 Qurdatic probing을 이용한다.    
Open Addressing은 키를 삭제하는 경우에 문제가 발생한다. probing을 하는 경우 중간에 있는 키를 삭제 하면, 이후에 있는 키를 찾는 경우에 찾지 못할 수도 있다.  
- 삭제를 표시하기 : 표시가 테이블 전체를 차지 할 수 있다.(해시의 장점이 사라짐) 
- 저장된 키들의 위치를 이동시키기 : 

### Hash함수를 만들때 중요한점
성능은 얼마나 균등하게 테이블에 배열되는 지가 결정한다. 현실에서는 키들이 랜덤하지 않다. key값이 비슷하더라도 해쉬함수의 값도 비슷해서는 안된다. 해쉬함수 값이 키의 특정 부분에 의해서만 결정 되면 안된다. 여러가지 방법이 사용된다.

#### Divison
키값에 mod연산을 이용하는 방법. 보통은 다른 방법을 사용한 후에 마지막에 적용한다. m은 보통 테이블 크기이다. 
```
hash(key) = key % m
```
한번의 mod연산으로 계산하므로 빠르다. 일부 mod값에 대해서는 키값의 특정 부분에 의해서 결정된다. ex) m^(2^p)라면 하위 p비트가 해쉬 함수 값이 된다.

#### Multiplication 
0~1사이의 상수 A를 선택(0 < A < 1)한다. key * A의 소수 부분에 m(테이블 크기)을 곱한 후 소수점 아래를 버린다.
```
A = 13/32, key = 21, m = 8;
Key * A = 273 / 32 = 8 + 17/32;
17/32 * 8 = 17/4 = 4.xxxx = 4;
hash(21) = 4 
```

