---
layout: post
title : Operating System 2
---
운영체제는 크고 복잡하다. 계속적인 개발을 필요로 한다.

## os의 기능
중재, 추상화, 기본 라이브러리
## 중재
Coodinator - 충돌에 대한 중재
## 추상화 Illusion generator
런타임 기능들(화면 표시, 키보드입력 등)을 제공
복잡한 것을 추상화시킴(HW를 몰라도 인터페이스를 제공)
추상레이어를 제공함, 여러유저에게 동일하게 제공함

### 추상화의 사례 
timesharing threshing
쓰레싱-타자를쳤는데 전달이 늦게됨,(원격접속할때 느끼지 않나?),사용자의 수가 일정 수준 넘으면 발생,tiemsharing(추상화 기능중 하나)의 task의 수가 너무 많음
## 기본 라이브러리
제공되는 드라이브들을 활용해서 프로그램을 작성 가능

## OS 구조
- cpu
- 메모리
- IO
- 파일 시스템 : 하드디스크-io
- 네트워크 시스템 : 네트워크 자료-io 

### I/O 장치의 3분류
1. Char I/O
2. Block I/O (대용량 데이터) - 파일시스템
io관리를 어떻게 하는가에 따라 성능이 결정된다.
3. Network I/O (소켓같은거):
큐에 데이터가 들어있다. 막히면 빨리가려고 해도 빨리 갈 수가 없음. 비디오같은게 지연 되면 문제가 된다. -> 속도에 민감한 패킷은 별로의 큐로 보낸다. 패킷스케줄링은  네트워크가 영향을 많이 받는다.

### 캐쉬
강의실로 데이터를 가져 온다면 캐쉬는 학교 정문에서 가져오는 정도이고 디스크는 달나라에서 가져오는 정도이다.
캐쉬를 메모리를 이용해서 소프트웨어적으로 구현할수도 있다.(디스크 캐시)

# 하드웨어 구성요소

## 시스템버스 
CPU - Memory - IO디바이스와 연결
버스는 Read와 Write 연산을 한다.
io디바이스는 컨트롤러를 가지고 있다.
이는 시스템 버스에 연결되어 있다.
### Data Bus 
실제 데이터를 전달 

### Address Bus
데이터의 Source와 Destnation지정

### bus master
버스를 사용할 수 있는 장치, 버스 사용을 위해서는 버스를 장악해야한다.
- CPU
- I/O Controller
- DMA

### Bus Slave
데이터를 담고 있는 장치, 주소를 가지고 있다.
- Memory
- IO Controller(장치의 Register)

### bus중재기
여러 마이스터가 버스를 요청하므로 조정해야한다.
리퀘스트 시그널을 받고 우선순위가 높은 거에 먼저 버스를 제공 grant신호를 받아서

## I/O Controller
cpu가 데이터 레지스터에 데이터가 저장되고 output명령, io장치가 가용하면 i/o수행

### 폴링 vs 인터럽트
Polling : I/O컨르롤러의 레지스터를 확인하면서 I/O가 끝날떄까지 기다림

### 메모리맵 vs 포트맵(io맵)
I/O Maped I/O : 장치를 위한 별도의 공간을 마련, Intel
Memory Maped I/O : 메모리의 일부를 사용함, 

## DMA Controller
대부분은 char I/O이지만, DMA는 block I/O같은 경우씀  끝나면 인터럽트
DMA는 CPU가 관여하지 않고 IO를 가능하게 한다. 이를 위해서 
CPU가 OP명령, DMA에 시작 주소, Block크기를 DMA로 넘겨준다.
- 싸이클 스틸링 : CPU가 버스를 사용하지 않을 때 점유 했다가 돌려줌
- 블록 트랜스퍼 : 대등하게 버스를 사용함

# HW 매커니즘     
## 인터럽트 매커니즘
OS를 위해서 HW가 지원하는 기능중 가장 중요한 기능 
OS는 Interrupt Driven 하다.
### HW인터럽트
cpu외부에서 cpu가 필요한 걸 알려줌, `비동기적`, 진행중에 갑자기 다른 일을 하게 되는 것, 프로세서에 인터럽트 시그널을 받는 Pin이 있어야한다. Pin에는 Interrupt 소스(IO 컨트롤러 등)가 연결되어 있다.  

### SW 인터럽트(Trap)
현재 수행하려는 것에 문제가 있을때(Exception), 임의로 int발생, 코드분석을 통해서 어디서 발생했는지 알수있다. `동기적`

개념의 이해 - 왜?? 어떻게??

int source -io장치들

### 인터럽트 과정
1. 현재 수행중인 프로그램의 명령어를 끝내고, 현재 상태(PC값 등)를 저장 
2. 현재 수행중인 프로그램을 중단. 
3. IRQ번호를 확인 
4. 벡터 테이블(ISR들이 저장) 검색 
5. ISR로 점프 후 수행
  
### 프로그래머블 인터럽트 컨트롤러
시스템이 복잡해지면서 인터럽트 핀이 많이 필요해짐 -> 확장성(scalebility)의 문제를 해결하기 위함.
입력 라인이 16개 까지 처리 가능하다면 그 이상이면 새로추가한다. 원래 핀에 여러개를 연결함으로 써 cascading으로 구현 한다.
특정 인터럽트를 disable시키는 경우가 필요
- Flag : 값에 따라 on, off, ISR 이 16개라면 flag가 16비트
- Mask regster : flag를 제어하기 위해 인터럽트 마스크하는 IO연산이 필요함(sw)
 
## HW protection
멀티 프로그래밍을 할때 여러 JOB이있는데 자신의 메모리가 아니라 다른 JOB의 메모리에  접근할 수 있어서
그를 막기위해 base레지스터와 bound 레지스터사용

### Priviliged instruction 실행을 위한 Mode
mode : 컴퓨터의 레지스터에 의해 결정(사람의 mood와 관련지어서 이해)   
mode = 0 kernel : privileged mode, superviser mode라고도 불림, Priviliged Instruction 수행가능    
mode = 1 user : Privileged instruction(메모리접근 같은거)은 불가  
user 프로그램은 기본적으로 신뢰하지 않는다. (버그가 있을 수 있기 때문) 그래서 통제적인 환경에서 수행 해야함.
명령을 해석할때 mode bit를 확인한다.

### OS가 커널 모드에서 수행될 때 부여받는 주요 권한
1. 모든 메모리 접근 
2. Privileged 명령어 사용

### 어떻게 모드를 바꾸어야 하는가?
모드를 os(무한신뢰의대상)가 정하도록한다.  
User가 I/O가 필요함(HW매커니즘이필요) -> Interrupt를 요청하면 커널모드로 해줌(SW INT)
Kernel에서 User로 가는 상황은 문제가 거의 없음

인터럽트는 낮은 수준, 함수 호출(High)로 가능하게 하는것은 System Call

### I/O 보호
여러 JOB들이 다른JOB을  건드리지 않도록, I/O를 특정 프로세스가 통제하는 것
->privileged inst.로 접근 함수를 만듬

## 메모리 보호
Base + bound를 이용해서 다른 JOB의 메모리에 접근하지 못하도록 한다.

## CPU 보호
운영체제가 항상 제어권을 확보할 수 있도록 해야한다. 
타이머 세팅 후 일정시간이 지나면 타이머 인터럽트를 이용해서 OS에 제어권을 넘긴다.