---
layout : post
title : 2017년 10월 12일 TIL
---
# 네트워크 

## 거리 벡터 알고리즘 
분산처리라서 직관적이지가 않음
바로 연결되지 않은 노드 들에서시작점은 바로 연결된 노드를 지나갈것이다.
```
D(x,y) = min{cost(x, v1) + D(v1, y), cost(x, v2) + D(v2, y)}
```
`(출발지에서 인접 노드 까지의 거리 + 인접노드에서 목적지까지의 거리)`가 제일 작은 것이 경로가 된다.
이웃간에 링크는 아는 값, 이웃부터 의 목적지는 구해야 하는 값
거리의 어레이(벡터)를 이웃에게 제공 받기 때문에 거리 벡터 알고리즘 이다.
자신의 벡터가 업데이트, 자신의 링크가 바뀌면 이웃에게 전달 한다. 전달 받은 노드는 자신의 정보를 업데이트 해야한다. 업데이트 되었으므로 이웃에 정보를 전달 해야한다.
업데이트 되지 않는다면 테이블이 계산 된 상황이다.

### Count to infinity
엣지의 비용이 바뀌면 업데이트가 계속 일어나느 경우 ,부분 정보에 의존해서 업데이트를 하기 때문에 발생. 비용이 감소하는 경우는 안정화가 빠르게 일어나지만
비용이 증가 하는 경우에는 이를 위해서는 거의 무한대로 알려줘야함.
넘겨주는 정보는 어떤 루트로 가는지는 표시되어 있지 않다. 리버스 패스가 생길수 있다. 

### Poison reverse
거리를 계산할때 결정적인 역할을 하는 이웃에게는 무한대로 넘겨준다.
