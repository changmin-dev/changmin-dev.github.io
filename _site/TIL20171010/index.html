<!DOCTYPE html>
<html>
  <head>
  <title>2017년 10월 10일 TIL – Changmin-dev – 잊어 버리지 않기 위해서</title>

      <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="알고리즘
프로그래머스 모의테스트 문제

" />
    <meta property="og:description" content="알고리즘
프로그래머스 모의테스트 문제

" />
    
    <meta name="author" content="Changmin-dev" />

    
    <meta property="og:title" content="2017년 10월 10일 TIL" />
    <meta property="twitter:title" content="2017년 10월 10일 TIL" />
    
  <!-- Async font loading -->
<script>
  window.WebFontConfig = {
      custom: {
          families: ['Spoqa Han Sans:100,300,400,700'],
          urls: ['https://spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css']
      },
      timeout: 60000
  };
  (function(d) {
      var wf = d.createElement('script'), s = d.scripts[0];
      wf.src = 'https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js';
      s.parentNode.insertBefore(wf, s);
  })(document);
</script>

  <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link rel="stylesheet" type="text/css" href="/style.css" />
  <link rel="alternate" type="application/rss+xml" title="Changmin-dev - 잊어 버리지 않기 위해서" href="/feed.xml" />

  <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->
</head>
  <body>
    <div class="wrapper-masthead">
  <div class="container">
    <header class="masthead clearfix">
      
        <a href="/" class="site-avatar"><img src="https://github.com/identicons/changmin-dev.png" /></a>
      

      <div class="site-info">
        <h1 class="site-name"><a href="/">Changmin-dev</a></h1>
        <p class="site-description">잊어 버리지 않기 위해서</p>
      </div>

      <nav>
        
        
        <a href="/">Blog</a>
        
        
        
        <a href="/about">About</a>
        
        
        
        <a href="/archive">Archive</a>
        
        
        
        <a href="/tags">Tags</a>
        
        
        
        <a href="https://github.com/AWEEKJ/kiko-now">Theme</a>
        
        
      </nav>
    </header>
  </div>
</div>

    <div id="main" role="main" class="container">
      <article class="post">
  <h1>2017년 10월 10일 TIL</h1>

  <div clsss="meta">
    <span class="date">
      2017-10-10
    </span>

    <ul class="tag">
      
    </ul>
  </div>

  <div class="entry">
    <h1 id="section">알고리즘</h1>
<p><a href="https://programmers.co.kr/tryouts/1467/intro">프로그래머스 모의테스트 문제</a></p>

<h2 id="section-1">가장 큰 정사각형(4번)</h2>
<p>처음에 내가 생각한 방식은 위치 (i,j)에서 (i-1, j), (i, j-1), (i-1, j-1)이 같다면 그 값에 1을 더한 값을 (i, j)의 값으로 설정하고 아니라면 3개 값중에 큰 값으로 하는 것이였다. 하지만 이 방식은 많은 오류를 뿜었다. 당연히 이전값을 이용해서 최종 값을 구하면 된다고 생각해서 한 방식인데, 기본 테스트 케이스는 성공 했지만, 많은 케이스에서 실패 했다.</p>

<h3 id="section-2">풀이</h3>
<p><a href="https://programmers.co.kr/learn/courses/18/lessons/847">프로그래머스</a>에서 풀이를 제공한다.</p>
<h3 id="section-3">코드</h3>
<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">P4</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="o">[][]</span><span class="n">board</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">DP</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">board</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">board</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">row</span> <span class="o">&lt;=</span> <span class="n">board</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">row</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">col</span> <span class="o">&lt;=</span> <span class="n">board</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">col</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">row</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">col</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                    <span class="n">DP</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">DP</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">-</span><span class="mi">1</span><span class="o">],</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">DP</span><span class="o">[</span><span class="n">row</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">col</span><span class="o">],</span> <span class="n">DP</span><span class="o">[</span><span class="n">row</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">col</span><span class="o">-</span><span class="mi">1</span><span class="o">]))</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="n">answer</span> <span class="o">=</span> <span class="o">(</span><span class="n">answer</span> <span class="o">&lt;</span> <span class="n">DP</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">])?</span> <span class="n">DP</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">:</span> <span class="n">answer</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">answer</span> <span class="o">*</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<h1 id="section-4">네트워크</h1>

<h2 id="section-5">네트워크 계층 개요</h2>
<p>TCP세그먼트를 어떻게 목적지까지 전송할 것인가?<br />
라우터, IP 프로토콜, 라우팅 알고리즘</p>

<p>이전의 계층과 달리, 중간에 라우터가 등장함</p>
<ul>
  <li>포워딩 :
라우터가 하는일. 목적지와 포워딩 테이블을 참조해서 패킷을 알맞은 곳으로 보낸다.</li>
  <li>포워딩 테이블 :
<code class="highlighter-rouge">특정 목적지로 가기 위해서는 어떤 목적지로 가야하는가?</code>에 대한 테이블</li>
  <li>라우팅 알고리즘 : 포워딩 테이블을 만든다.</li>
  <li>Longist prefix matching : 가장 구체적인 것과 매칭</li>
</ul>

<h2 id="ip-datagram-format">IP datagram format</h2>
<p>총 20바이트가 된다. TCP도 20바이트. 40바이트는 오버헤드이다. 인터넷에서는 40바이트크기의 패킷이 많은 비중을 차지한다.(TCP ACK)</p>
<ul>
  <li>length</li>
  <li>source ip address</li>
  <li>dest ip address</li>
  <li>TTL(Time to live) : 0이 되는 순간 패킷은 버려진다. 포워딩이 잘못되면 네트워크 자원만 소모하고 목적지에 못가게 되서 버림</li>
  <li>Upper layer : tcp? udp? 여부</li>
</ul>

<h2 id="ip-address">IP Address</h2>
<p>호스트에 들어 있는 네트워크 인터페이스(NIC 등)를 지칭하는 주소
32비트 주소체계(IPv4), 2^32개의 주소
8비트씩 끊어서 0~255씩 4개로 읽는다.</p>

<h3 id="section-6">라우터의 인터페이스</h3>
<p>네트워크 인터페이스가 여러개이다.</p>

<h3 id="ip--">IP 주소 배정</h3>
<p>막무가네로 배정하지 않는다. 포워딩 테이블이 커진다.
32비트 IP공간은 두부분으로 나누어진다.
Network ID
Host ID - 같은 네트워크에 있는 Host는 같은 네트워크 Id를 가진다.</p>

<h3 id="subnet-mask">Subnet Mask</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>12.34.156.0/24
</code></pre>
</div>
<p>위에서 24는 prefix 24비트를 네트워크 ID를 사용한다는 의미 <br />
내부와는 상관없이 포워딩 할때는 prefix만 신경 쓰면 된다.</p>

<h3 id="ip-class">IP Class배분</h3>
<p>예전에는 클래스를 나누었다. 애매한 경우가 많아서 현재는 사용안함</p>
<ul>
  <li>Class A : <code class="highlighter-rouge">0.x.x.x/8</code> 2^24개의 host를 가질수 있는 128개의 네트워크, 초기의 선점자들이 가져감, 한 기관이 전부 사용 못할 정도</li>
  <li>Class B : <code class="highlighter-rouge">x.x.x.x/16</code> 6만개 정도</li>
  <li>Class C : <code class="highlighter-rouge">x.x.x.x/24</code> 개수는 많지만 많이 사용은 못함</li>
</ul>

<p>ex)1000개 사용 -&gt; C 4개, 포워딩이 복잡해짐</p>

<h3 id="cidrclassless-inter-domain-routing">CIDR(Classless Inter-Domain Routing)</h3>
<p>클래스를 사용안하고 자유롭게 끊어서 사용, 포워딩 테이블도 단순해 진다.
ex) 1000개 사용 -&gt; x.x.x.x/22</p>

<h3 id="longest-preix-match-forwarding">Longest Preix Match Forwarding</h3>
<p>여러개 매칭이되면, 가장 구체적으로 매칭되는 것을 선택한다. Prefix의 크기가 큰것!</p>
<div class="highlighter-rouge"><pre class="highlight"><code>201.10.6.17 -&gt;  4.0.0.0/8
                201.10.0.0/21
                201.10.6.0/23 -&gt; outgoing
</code></pre>
</div>

<h3 id="section-7">서브넷</h3>
<p>정의</p>
<ol>
  <li>같은 subnet id, 같은 prefix를 가진 장치의 집합</li>
  <li>라우터를 거치지 않고 접근 가능한 호스트들의 집합</li>
</ol>

<p>라우터는 여러 서브넷에 속한다. 그래서 라우터를 통해서 다른 호스트에 갈수 있다.</p>

<h3 id="nat-">NAT 개요</h3>
<p>IPv4은 32비트로 2^32(40억) host이다. 여기에 한계가 있어서 만든 v6은 더 많은 128비트를 사용한다.
하지만 현재도 v4를 사용한다. 한정된 공간에서 더 많은 
host를 사용하기 위한 기법이 NAT이다. <code class="highlighter-rouge">내부에서 외부에서 통용되는 IP로 바꾸어 준다.</code>
NAT 테이블에 맞추어 포트번호와 IP를 바꾸어준다. 포트번호도 기억하는 이유는 다시 돌아 왔을때 어느 포트번호로 보내야할지 알아야 하기 때문이다.</p>

<h4 id="section-8">문제점</h4>
<ol>
  <li>패킷은 IP/TCP/DATA으로 되어 있는데 변환이 된다면 TCP의 포트넘버도 바꾸어야함</li>
  <li>포트넘버는 프로세스를 찾아 가기 위한 정보이다. 포트가 바뀐다면 NAT내부에서는 서버를 운영 할 수가 없다.</li>
</ol>

  </div>

  <div class="pagination">
    
      <span class="prev" >
          <a href="/TIL20171009/">
            &#xE000; 2017년 10월 9일
          </a>
      </span>
    
    
      <span class="next" >
          <a href="/TIL20171011/">
            2017년 10월 11일 TIL &#xE001;
          </a>
      </span>
    
  </div>

  
</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          <!-- Refer to https://codepen.io/ruandre/pen/howFi -->
<ul class="svg-icon">

  

  

  

  

  

  
  <li><a href="https://github.com/changmin-dev" class="icon-13 github" title="GitHub"><svg viewBox="0 0 512 512"><path d="M256 70.7c-102.6 0-185.9 83.2-185.9 185.9 0 82.1 53.3 151.8 127.1 176.4 9.3 1.7 12.3-4 12.3-8.9V389.4c-51.7 11.3-62.5-21.9-62.5-21.9 -8.4-21.5-20.6-27.2-20.6-27.2 -16.9-11.5 1.3-11.3 1.3-11.3 18.7 1.3 28.5 19.2 28.5 19.2 16.6 28.4 43.5 20.2 54.1 15.4 1.7-12 6.5-20.2 11.8-24.9 -41.3-4.7-84.7-20.6-84.7-91.9 0-20.3 7.3-36.9 19.2-49.9 -1.9-4.7-8.3-23.6 1.8-49.2 0 0 15.6-5 51.1 19.1 14.8-4.1 30.7-6.2 46.5-6.3 15.8 0.1 31.7 2.1 46.6 6.3 35.5-24 51.1-19.1 51.1-19.1 10.1 25.6 3.8 44.5 1.8 49.2 11.9 13 19.1 29.6 19.1 49.9 0 71.4-43.5 87.1-84.9 91.7 6.7 5.8 12.8 17.1 12.8 34.4 0 24.9 0 44.9 0 51 0 4.9 3 10.7 12.4 8.9 73.8-24.6 127-94.3 127-176.4C441.9 153.9 358.6 70.7 256 70.7z"/></svg><!--[if lt IE 9]><em>GitHub</em><![endif]--></a></li>
  

  

  

  

  

  

  

  

  

  

</ul>



<p>© 2017 Kiko Now</p>

        </footer>
      </div>
    </div>

    

  </body>
</html>
