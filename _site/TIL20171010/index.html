<!DOCTYPE html>
<html>
  <head>
    <title>2017년 10월 10일 TIL – Twibeat – 잊어 버리지 않기 위해서</title>

        <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="알고리즘
프로그래머스 모의테스트 문제

" />
    <meta property="og:description" content="알고리즘
프로그래머스 모의테스트 문제

" />
    
    <meta name="author" content="Twibeat" />

    
    <meta property="og:title" content="2017년 10월 10일 TIL" />
    <meta property="twitter:title" content="2017년 10월 10일 TIL" />
    

    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" title="Twibeat - 잊어 버리지 않기 위해서" href="/feed.xml" />

    <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="/" class="site-avatar"><img src="https://github.com/identicons/changmin-dev.png" /></a>

          <div class="site-info">
            <h1 class="site-name"><a href="/">Twibeat</a></h1>
            <p class="site-description">잊어 버리지 않기 위해서</p>
          </div>

          <nav>
            <a href="/">Blog</a>
            <a href="/TIL">TIL</a>
            <a href="/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
  <h1>2017년 10월 10일 TIL</h1>

  <div class="entry">
    <h1 id="알고리즘">알고리즘</h1>
<p><a href="https://programmers.co.kr/tryouts/1467/intro">프로그래머스 모의테스트 문제</a></p>

<h2 id="가장-큰-정사각형4번">가장 큰 정사각형(4번)</h2>
<p>처음에 내가 생각한 방식은 위치 (i,j)에서 (i-1, j), (i, j-1), (i-1, j-1)이 같다면 그 값에 1을 더한 값을 (i, j)의 값으로 설정하고 아니라면 3개 값중에 큰 값으로 하는 것이였다. 하지만 이 방식은 많은 오류를 뿜었다. 당연히 이전값을 이용해서 최종 값을 구하면 된다고 생각해서 한 방식인데, 기본 테스트 케이스는 성공 했지만, 많은 케이스에서 실패 했다.</p>

<h3 id="풀이">풀이</h3>
<p><a href="https://programmers.co.kr/learn/courses/18/lessons/847">프로그래머스</a>에서 풀이를 제공한다.</p>
<h3 id="코드">코드</h3>
<div class="language-java highlighter-rouge"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">P4</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">solution</span><span class="o">(</span><span class="kt">int</span> <span class="o">[][]</span><span class="n">board</span><span class="o">)</span>
    <span class="o">{</span>
        <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
        <span class="kt">int</span><span class="o">[][]</span> <span class="n">DP</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">board</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="n">board</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>

        <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">row</span> <span class="o">&lt;=</span> <span class="n">board</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">row</span><span class="o">){</span>
            <span class="k">for</span><span class="o">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">col</span> <span class="o">&lt;=</span> <span class="n">board</span><span class="o">[</span><span class="mi">0</span><span class="o">].</span><span class="na">length</span><span class="o">;</span> <span class="o">++</span><span class="n">col</span><span class="o">){</span>
                <span class="k">if</span><span class="o">(</span><span class="n">board</span><span class="o">[</span><span class="n">row</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">col</span><span class="o">-</span><span class="mi">1</span><span class="o">]</span> <span class="o">==</span> <span class="mi">1</span><span class="o">){</span>
                    <span class="n">DP</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">DP</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">-</span><span class="mi">1</span><span class="o">],</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">DP</span><span class="o">[</span><span class="n">row</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">col</span><span class="o">],</span> <span class="n">DP</span><span class="o">[</span><span class="n">row</span><span class="o">-</span><span class="mi">1</span><span class="o">][</span><span class="n">col</span><span class="o">-</span><span class="mi">1</span><span class="o">]))</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
                    <span class="n">answer</span> <span class="o">=</span> <span class="o">(</span><span class="n">answer</span> <span class="o">&lt;</span> <span class="n">DP</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">])?</span> <span class="n">DP</span><span class="o">[</span><span class="n">row</span><span class="o">][</span><span class="n">col</span><span class="o">]</span> <span class="o">:</span> <span class="n">answer</span><span class="o">;</span>
                <span class="o">}</span>
            <span class="o">}</span>
        <span class="o">}</span>

        <span class="k">return</span> <span class="n">answer</span> <span class="o">*</span> <span class="n">answer</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre>
</div>

<h1 id="네트워크">네트워크</h1>

<h2 id="네트워크-계층-개요">네트워크 계층 개요</h2>
<p>TCP세그먼트를 어떻게 목적지까지 전송할 것인가?<br />
라우터, IP 프로토콜, 라우팅 알고리즘</p>

<p>이전의 계층과 달리, 중간에 라우터가 등장함</p>
<ul>
  <li>포워딩 :
라우터가 하는일. 목적지와 포워딩 테이블을 참조해서 패킷을 알맞은 곳으로 보낸다.</li>
  <li>포워딩 테이블 :
<code class="highlighter-rouge">특정 목적지로 가기 위해서는 어떤 목적지로 가야하는가?</code>에 대한 테이블</li>
  <li>라우팅 알고리즘 : 포워딩 테이블을 만든다.</li>
  <li>Longist prefix matching : 가장 구체적인 것과 매칭</li>
</ul>

<h2 id="ip-datagram-format">IP datagram format</h2>
<p>총 20바이트가 된다. TCP도 20바이트. 40바이트는 오버헤드이다. 인터넷에서는 40바이트크기의 패킷이 많은 비중을 차지한다.(TCP ACK)</p>
<ul>
  <li>length</li>
  <li>source ip address</li>
  <li>dest ip address</li>
  <li>TTL(Time to live) : 0이 되는 순간 패킷은 버려진다. 포워딩이 잘못되면 네트워크 자원만 소모하고 목적지에 못가게 되서 버림</li>
  <li>Upper layer : tcp? udp? 여부</li>
</ul>

<h2 id="ip-address">IP Address</h2>
<p>호스트에 들어 있는 네트워크 인터페이스(NIC 등)를 지칭하는 주소
32비트 주소체계(IPv4), 2^32개의 주소
8비트씩 끊어서 0~255씩 4개로 읽는다.</p>

<h3 id="라우터의-인터페이스">라우터의 인터페이스</h3>
<p>네트워크 인터페이스가 여러개이다.</p>

<h3 id="ip-주소-배정">IP 주소 배정</h3>
<p>막무가네로 배정하지 않는다. 포워딩 테이블이 커진다.
32비트 IP공간은 두부분으로 나누어진다.
Network ID
Host ID - 같은 네트워크에 있는 Host는 같은 네트워크 Id를 가진다.</p>

<h3 id="subnet-mask">Subnet Mask</h3>
<div class="highlighter-rouge"><pre class="highlight"><code>12.34.156.0/24
</code></pre>
</div>
<p>위에서 24는 prefix 24비트를 네트워크 ID를 사용한다는 의미 <br />
내부와는 상관없이 포워딩 할때는 prefix만 신경 쓰면 된다.</p>

<h3 id="ip-class배분">IP Class배분</h3>
<p>예전에는 클래스를 나누었다. 애매한 경우가 많아서 현재는 사용안함</p>
<ul>
  <li>Class A : <code class="highlighter-rouge">0.x.x.x/8</code> 2^24개의 host를 가질수 있는 128개의 네트워크, 초기의 선점자들이 가져감, 한 기관이 전부 사용 못할 정도</li>
  <li>Class B : <code class="highlighter-rouge">x.x.x.x/16</code> 6만개 정도</li>
  <li>Class C : <code class="highlighter-rouge">x.x.x.x/24</code> 개수는 많지만 많이 사용은 못함</li>
</ul>

<p>ex)1000개 사용 -&gt; C 4개, 포워딩이 복잡해짐</p>

<h3 id="cidrclassless-inter-domain-routing">CIDR(Classless Inter-Domain Routing)</h3>
<p>클래스를 사용안하고 자유롭게 끊어서 사용, 포워딩 테이블도 단순해 진다.
ex) 1000개 사용 -&gt; x.x.x.x/22</p>

<h3 id="longest-preix-match-forwarding">Longest Preix Match Forwarding</h3>
<p>여러개 매칭이되면, 가장 구체적으로 매칭되는 것을 선택한다. Prefix의 크기가 큰것!</p>
<div class="highlighter-rouge"><pre class="highlight"><code>201.10.6.17 -&gt;  4.0.0.0/8
                201.10.0.0/21
                201.10.6.0/23 -&gt; outgoing
</code></pre>
</div>

<h3 id="서브넷">서브넷</h3>
<p>정의</p>
<ol>
  <li>같은 subnet id, 같은 prefix를 가진 장치의 집합</li>
  <li>라우터를 거치지 않고 접근 가능한 호스트들의 집합</li>
</ol>

<p>라우터는 여러 서브넷에 속한다. 그래서 라우터를 통해서 다른 호스트에 갈수 있다.</p>

<h3 id="nat-개요">NAT 개요</h3>
<p>IPv4은 32비트로 2^32(40억) host이다. 여기에 한계가 있어서 만든 v6은 더 많은 128비트를 사용한다.
하지만 현재도 v4를 사용한다. 한정된 공간에서 더 많은 
host를 사용하기 위한 기법이 NAT이다. <code class="highlighter-rouge">내부에서 외부에서 통용되는 IP로 바꾸어 준다.</code>
NAT 테이블에 맞추어 포트번호와 IP를 바꾸어준다. 포트번호도 기억하는 이유는 다시 돌아 왔을때 어느 포트번호로 보내야할지 알아야 하기 때문이다.</p>

<h4 id="문제점">문제점</h4>
<ol>
  <li>패킷은 IP/TCP/DATA으로 되어 있는데 변환이 된다면 TCP의 포트넘버도 바꾸어야함</li>
  <li>포트넘버는 프로세스를 찾아 가기 위한 정보이다. 포트가 바뀐다면 NAT내부에서는 서버를 운영 할 수가 없다.</li>
</ol>

  </div>

  <div class="date">
    Written on October 10, 2017
  </div>

  
</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          



<a href="https://github.com/changmin-dev"><i class="svg-icon github"></i></a>








        </footer>
      </div>
    </div>

    

  </body>
</html>
