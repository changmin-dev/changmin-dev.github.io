<!DOCTYPE html>
<html>
  <head>
  <title>2017년 10월 7일 TIL – Changmin-dev – 잊어 버리지 않기 위해서</title>

      <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="네트워크
약자의 원래 이름과 왜 이런지 생각하기

" />
    <meta property="og:description" content="네트워크
약자의 원래 이름과 왜 이런지 생각하기

" />
    
    <meta name="author" content="Changmin-dev" />

    
    <meta property="og:title" content="2017년 10월 7일 TIL" />
    <meta property="twitter:title" content="2017년 10월 7일 TIL" />
    
  <!-- Async font loading -->
<script>
  window.WebFontConfig = {
      custom: {
          families: ['Spoqa Han Sans:100,300,400,700'],
          urls: ['https://spoqa.github.io/spoqa-han-sans/css/SpoqaHanSans-kr.css']
      },
      timeout: 60000
  };
  (function(d) {
      var wf = d.createElement('script'), s = d.scripts[0];
      wf.src = 'https://ajax.googleapis.com/ajax/libs/webfont/1.5.18/webfont.js';
      s.parentNode.insertBefore(wf, s);
  })(document);
</script>

  <!--[if lt IE 9]>
    <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link rel="stylesheet" type="text/css" href="/style.css" />
  <link rel="alternate" type="application/rss+xml" title="Changmin-dev - 잊어 버리지 않기 위해서" href="/feed.xml" />

  <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->
</head>
  <body>
    <div class="wrapper-masthead">
  <div class="container">
    <header class="masthead clearfix">
      
        <a href="/" class="site-avatar"><img src="https://github.com/identicons/changmin-dev.png" /></a>
      

      <div class="site-info">
        <h1 class="site-name"><a href="/">Changmin-dev</a></h1>
        <p class="site-description">잊어 버리지 않기 위해서</p>
      </div>

      <nav>
        
        
        <a href="/">Blog</a>
        
        
        
        <a href="/about">About</a>
        
        
        
        <a href="/archive">Archive</a>
        
        
        
        <a href="/tags">Tags</a>
        
        
        
        <a href="https://github.com/AWEEKJ/kiko-now">Theme</a>
        
        
      </nav>
    </header>
  </div>
</div>

    <div id="main" role="main" class="container">
      <article class="post">
  <h1>2017년 10월 7일 TIL</h1>

  <div clsss="meta">
    <span class="date">
      2017-10-07
    </span>

    <ul class="tag">
      
    </ul>
  </div>

  <div class="entry">
    <h1 id="section">네트워크</h1>
<p>약자의 원래 이름과 왜 이런지 생각하기</p>

<h2 id="section-1">패킷</h2>
<p>패킷은 비트들의 묶음으로 중간 중간 라우터를 거쳐서 이동 한다.
패킷을 검사한다는 것은 <code class="highlighter-rouge">목적지가 어디인가?</code>를 알아 내는것<br />
프로파게이션은 빛의 속도 이므로 앞부분은 이미 도착 할 수 있다.
패킷의 앞부분이 도착하면 모든 부분이 올때까지 기다려야 한다.
<code class="highlighter-rouge">치킨</code> <code class="highlighter-rouge">ㅊ</code>이 온다고 가는게 아니라 <code class="highlighter-rouge">ㅊㅣㅋㅣ</code>이 와야 다음 목적지로 이동 한다.</p>

<h2 id="section-2">인터넷 프로토콜 스택</h2>

<table>
  <thead>
    <tr>
      <th>이   름</th>
      <th>주요 프로토콜</th>
      <th style="text-align: center"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Application</td>
      <td>HTTP</td>
      <td style="text-align: center">Process의 위치</td>
    </tr>
    <tr>
      <td>Transport</td>
      <td>TCP, UDP</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td>Network</td>
      <td>IP</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td>Data Link</td>
      <td>Ethernet, WIFI</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td>Physical</td>
      <td>Twisted Pair</td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>

<p>라우터의 계층은 네트워크 까지만 존재한다.</p>

<table>
  <thead>
    <tr>
      <th>이   름</th>
      <th>주요 프로토콜</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Network</td>
      <td>IP</td>
    </tr>
    <tr>
      <td>Data Link</td>
      <td>Ethernet, WIFI</td>
    </tr>
    <tr>
      <td>Physical</td>
      <td>Twisted Pair</td>
    </tr>
  </tbody>
</table>

<h2 id="ip-">IP 주소</h2>
<p>IP 인터넷 상의 각 컴퓨는 각각의 주소를 가지고 있다. 이를 IP주소라고 한다.</p>
<ul>
  <li>서버 : 고정된 ip주소 필요하다. 사람들이 찾아간다.윛기가 바뀐다면 찾기 힘듬</li>
  <li>클라이언트 : 고정되지 않아도 된다.</li>
</ul>

<h2 id="ipc-----">IPC를 위한 인터페이스 - 소켓</h2>
<p>소켓의 인덱싱(주소 역할)하는 것은 IP 주소와 포트번호(프로세스를 구별 하기 위함)
브라우저에서 입력하는 방법 www.naver.com
실제로는 www.naver.com:80 포트는 생략하면 80으로</p>

<h3 id="section-3">어플리케이션끼리 같은 포트를 사용하는 이유?</h3>
<p>서버 24시간 켜야하고, 주소가 일정해야 한다.
DNS는 주소만 해석한다. 포트가 다르면 포트에대한 처리를 해주어야함</p>

<h2 id="section-4">트랜스포트 계층에서 기대 되는것</h2>
<ol>
  <li><code class="highlighter-rouge">데이타 무결성</code> - 이것만 가능!!!</li>
  <li>타이밍</li>
  <li>쓰루풋</li>
  <li>보안</li>
</ol>

<h2 id="httphyper-text-transfer-protocol">HTTP(Hyper Text Transfer Protocol)</h2>
<p>하이퍼텍스트? - 택스트 인데 중간에 링크들이 있음<br />
HTTP는 대부분 TCP를 사용해서 TCP 커넥션이 필요하다.<br />
HTTP는 state less이다. 상태를 기억하지 않는다.</p>

<h3 id="non-persistent-http">Non Persistent HTTP</h3>
<p>TCP연결을 설정, 상대편이 설정하면 연결완료되면 HTTP통신을 한다. 이후 TCP연결을 해제 한다. 
1개 페이지가 여러개로 구성되어 있다면 계속 TCP부터 연결을 한다.</p>

<h3 id="persistent-http">Persistent HTTP</h3>
<p>연결을 재사용 한다. 클라이언트에서 정보를 다 받았다고 판단 했을때 TCP연결 해재한다. 실제는 보통 persistent를 사용한다.</p>

<p>실제로는 한번에 리소스 여러개 요청을 보낸다.(파이프라인 방식)</p>

<h2 id="section-5">소켓 프로그레밍</h2>
<p>어플리케이션 프로그램 OS가 아니다. OS에서 제공하는 서비스를 사용 OS가 제공하는 인터페이스를 사용하는것이다.
TCP/UDP에 맞게 해당하는 소켓을 사용해서 데이터를 주고 받는다.</p>

<h2 id="section-6">멀티 플랙싱과 디멀티 플랙싱</h2>
<p>TCP에서는 세그먼트를 주고 받는다. 이는 어플리케이션 측 데이터에 TCP헤더가 추가된것이다.</p>

<h3 id="section-7">멀티플랙싱</h3>
<p>Sender가 어플리케이션에서 전달된 다양한 데이터를 세그먼트로 만들어줌</p>

<h3 id="section-8">디멀티 플랙싱</h3>
<p>Reciver가 세그먼트에 맞게 어플리케이션 계층에 데이터를 전달</p>

<h2 id="transfer-layer-header">Transfer layer의 Header</h2>
<p>헤더의 여러필드가 있는데 그중에서 중요한 것은 소스와 데스트네이션의 포트번호이다.
클라이언트에서 소스는 자신의 포트이고 데스트네이션은 서버의 포트이다.</p>

<h3 id="tcp-">TCP의 경우</h3>
<p>TCP는 소켓을 구별한다. 소스, 데스네이션 각각의 아이피와 포트번호 4가지 중 하나라도 틀리면 다른 소켓이다.
TCP 연결지향 - 특정 연결에 대한 소켓을 만든다. 자원소모가 크다.</p>
<ul>
  <li>브로드 캐스트 : 각각 TCP연결을 한다.</li>
</ul>

<h3 id="udp-">UDP의 경우</h3>
<p>UDP는 아무나 전달, 그냥 소켓으로 전달만함 
UDP는 신뢰성 보장을 하지 않는다. 하지만 트랜스포트에서 제공하는 것은 제공함</p>

<h3 id="udp--">UDP 헤더 필드</h3>
<p>TCP에 비해 간단하다. 
소스포트 16비트 /목적지포트 16비트/ Length(멀티플랙싱, 디멀티 플랙싱에 사용) /체크섬
체크섬으로 에러 파악, 전송하지 않고 죽이는 식</p>

<h2 id="transport-">Transport에서 해주어야하는거</h2>
<p>멀티플랙싱과 에러채킹(에러가 발생하면 어플리케이션으로 가지 않는다.) 이는 UDP도 동일하다.</p>

<h2 id="relable-data-tranfer-protocol">Relable data tranfer protocol</h2>
<p>TCP 4가지 특징중 가장 중요한건 릴라이어블 통신 환경은 사실 불안전하다.</p>
<ol>
  <li>패킷의 유실</li>
  <li>패킷 에러</li>
</ol>

<h3 id="section-9">1.0 단순한 버전</h3>
<p>에러와 유실이 없는 경우</p>
<ul>
  <li>sender - 그냥 보냄</li>
  <li>reciver - 그냥 받음</li>
</ul>

<h3 id="section-10">2.0 에러가 있는 경우</h3>
<ul>
  <li>Error 탐지 : 체크섬을 추가</li>
  <li>Feed back : 패킷을 받을때마다 Ack/Nak
(Negative Ack)를 보냄</li>
  <li>재전송 : Nak받으면 재전송
Sender - 채크섬을 추가해서 보냄
Reciver - 체크섬확인 후 애러여부를 송신
피드백도 체크섬이 필요 피드백도 에러가 있을수 있다.
피드백이 망가진경우 다시 보낸다.</li>
</ul>

<h3 id="section-11">2.1 리시버가 중복데이터를 받으면 다시보낸건지 알수 없다.</h3>
<p>구별이 필요 -&gt; 패킷에 번호를 붙인다. -&gt; sequence number
sqeunce number 붙이는 법
header붙인다. - 부가정보니까
순서대로 붙인다. - 크기가 무한대가 됨 하지만 ㄴ헤더크기는 작을 수록 좋다. 최소한의 필드만 있어야 한다.
2개면 충분 - 0, 1 
0 받았으면 1기다림, 1받았으면 0기다림</p>

<h3 id="nak--">2.2 NAK를 없앤 프로토콜</h3>
<p>ACK에 가장 마지막에 받은 sequnce를 보낸다.
ACK번호가 이전과 같으면 애러</p>

<h3 id="section-12">3.0 메세지 유실여부까지 추가</h3>
<ul>
  <li>유실 - 유실되면 ACK가 안옴 <br />
타이머를 넣는다. 
메세지를 보내고 타이머를 돌림<br />
얼마나 기다려야 하는가?</li>
</ul>

<h4 id="trade-off">Trade off</h4>
<p>시간이 짧음 - 실제 유실이 일어난경우 복구가 빠르다. 중복된걸 받을수 있다. - 지연됬는데도 유실로 처리되어서, 네트워크 오버헤드
시간이 길다 - 유실에 대한 반응이 늦다. 복구가 느림</p>

<h3 id="section-13">성능 측정</h3>
<p>Utilization - 전체 시간중에 sender가 메시지를 보내는 비율</p>

<h2 id="tcp-header">TCP Header</h2>
<p>에러,손실처리, 나머지 기능을 = 처리하기 위한것을 처리</p>

<h2 id="section-14">파이프라이닝</h2>
<p>실제는 하니씩 보내는게 아니라 한꺼번에 보낸다. 하나씩 보내는것 보다. Utilization이 높아짐</p>
<ol>
  <li>Go-Back-N</li>
  <li>Selected Repeat</li>
</ol>

<h3 id="go-back-n">GO-Back-N</h3>
<ul>
  <li>window : 한번에 얼마 만큼 보낼것인가?</li>
  <li>Ack(n) : n개까지 받았다.</li>
  <li>타이머 : 패킷마다 타이머가 존재, 타임아웃되면 해당 패킷 포함해서 이후는 전부 재전송</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>1 2 3 4 5 x 7 8 9(6 이후 버림)
          6 7 8 9
</code></pre>
</div>
<p>샌더는 윈도우에 있는 패킷은 버퍼에 저장-리시버가 받았는지를 모름</p>

<h3 id="selected-repeat">Selected Repeat</h3>
<p>없어진 것만 재전송 
Ack(n) : n번 패킷을 받았다. 순서가 맞지 않아도 버퍼에 저장한다.</p>
<div class="highlighter-rouge"><pre class="highlight"><code>1234 -&gt; 1 34(버퍼에 저장)
     &lt;- 1, 3, 4 ACK
   2 -&gt; 1234
     &lt;- 2 ACK
</code></pre>
</div>
<p>모든 패킷에 타이머를? 윈도우의 크기가 크면 문제가 발생</p>

<h3 id="sequnce-number">Sequnce number</h3>
<p>최소한의 sequence number가 효율적이므로 재사용한다.
N을 윈도우 사이즈라고 한다면,
짧으면 N+1개 -&gt; 0번이 유실되면 다음에 들어오는 0이 다음껀지 이번껀지 혼동 될수있다.
범위를 늘린다. -&gt; 늘리면 비효율 ㅠ
<code class="highlighter-rouge">구별이 되는 최소의 범위를 찾기</code> 
약 2*N개(시스템마다 다를 수 있다.)</p>

<h2 id="tcp---">TCP에서 파이프 라인 구현</h2>
<p>2가지 방법의 장점을 취합해서 구현한다.
윈도우 마다 타이머를 설정, GBN의 ACK를 사용</p>


  </div>

  <div class="pagination">
    
      <span class="prev" >
          <a href="/TIL20171006/">
            &#xE000; 2017년 10월 6일
          </a>
      </span>
    
    
      <span class="next" >
          <a href="/TIL20171008/">
            2017년 10월 8일 TIL &#xE001;
          </a>
      </span>
    
  </div>

  
</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          <!-- Refer to https://codepen.io/ruandre/pen/howFi -->
<ul class="svg-icon">

  

  

  

  

  

  
  <li><a href="https://github.com/changmin-dev" class="icon-13 github" title="GitHub"><svg viewBox="0 0 512 512"><path d="M256 70.7c-102.6 0-185.9 83.2-185.9 185.9 0 82.1 53.3 151.8 127.1 176.4 9.3 1.7 12.3-4 12.3-8.9V389.4c-51.7 11.3-62.5-21.9-62.5-21.9 -8.4-21.5-20.6-27.2-20.6-27.2 -16.9-11.5 1.3-11.3 1.3-11.3 18.7 1.3 28.5 19.2 28.5 19.2 16.6 28.4 43.5 20.2 54.1 15.4 1.7-12 6.5-20.2 11.8-24.9 -41.3-4.7-84.7-20.6-84.7-91.9 0-20.3 7.3-36.9 19.2-49.9 -1.9-4.7-8.3-23.6 1.8-49.2 0 0 15.6-5 51.1 19.1 14.8-4.1 30.7-6.2 46.5-6.3 15.8 0.1 31.7 2.1 46.6 6.3 35.5-24 51.1-19.1 51.1-19.1 10.1 25.6 3.8 44.5 1.8 49.2 11.9 13 19.1 29.6 19.1 49.9 0 71.4-43.5 87.1-84.9 91.7 6.7 5.8 12.8 17.1 12.8 34.4 0 24.9 0 44.9 0 51 0 4.9 3 10.7 12.4 8.9 73.8-24.6 127-94.3 127-176.4C441.9 153.9 358.6 70.7 256 70.7z"/></svg><!--[if lt IE 9]><em>GitHub</em><![endif]--></a></li>
  

  

  

  

  

  

  

  

  

  

</ul>



<p>© 2017 Kiko Now</p>

        </footer>
      </div>
    </div>

    

  </body>
</html>
