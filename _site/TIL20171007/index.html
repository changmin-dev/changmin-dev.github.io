<!DOCTYPE html>
<html>
  <head>
    <title>2017년 10월 7일 TIL – Twibeat – 잊어 버리지 않기 위해서</title>

        <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="네트워크
약자의 원래 이름과 왜 이런지 생각하기

" />
    <meta property="og:description" content="네트워크
약자의 원래 이름과 왜 이런지 생각하기

" />
    
    <meta name="author" content="Twibeat" />

    
    <meta property="og:title" content="2017년 10월 7일 TIL" />
    <meta property="twitter:title" content="2017년 10월 7일 TIL" />
    

    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" title="Twibeat - 잊어 버리지 않기 위해서" href="/feed.xml" />

    <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="/" class="site-avatar"><img src="https://github.com/identicons/changmin-dev.png" /></a>

          <div class="site-info">
            <h1 class="site-name"><a href="/">Twibeat</a></h1>
            <p class="site-description">잊어 버리지 않기 위해서</p>
          </div>

          <nav>
            <a href="/">Blog</a>
            <a href="/TIL">TIL</a>
            <a href="/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
  <h1>2017년 10월 7일 TIL</h1>

  <div class="entry">
    <h1 id="네트워크">네트워크</h1>
<p>약자의 원래 이름과 왜 이런지 생각하기</p>

<h2 id="패킷">패킷</h2>
<p>패킷은 비트들의 묶음으로 중간 중간 라우터를 거쳐서 이동 한다.
패킷을 검사한다는 것은 <code class="highlighter-rouge">목적지가 어디인가?</code>를 알아 내는것<br />
프로파게이션은 빛의 속도 이므로 앞부분은 이미 도착 할 수 있다.
패킷의 앞부분이 도착하면 모든 부분이 올때까지 기다려야 한다.
<code class="highlighter-rouge">치킨</code> <code class="highlighter-rouge">ㅊ</code>이 온다고 가는게 아니라 <code class="highlighter-rouge">ㅊㅣㅋㅣ</code>이 와야 다음 목적지로 이동 한다.</p>

<h2 id="인터넷-프로토콜-스택">인터넷 프로토콜 스택</h2>

<table>
  <thead>
    <tr>
      <th>이   름</th>
      <th>주요 프로토콜</th>
      <th style="text-align: center"> </th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Application</td>
      <td>HTTP</td>
      <td style="text-align: center">Process의 위치</td>
    </tr>
    <tr>
      <td>Transport</td>
      <td>TCP, UDP</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td>Network</td>
      <td>IP</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td>Data Link</td>
      <td>Ethernet, WIFI</td>
      <td style="text-align: center"> </td>
    </tr>
    <tr>
      <td>Physical</td>
      <td>Twisted Pair</td>
      <td style="text-align: center"> </td>
    </tr>
  </tbody>
</table>

<p>라우터의 계층은 네트워크 까지만 존재한다.</p>

<table>
  <thead>
    <tr>
      <th>이   름</th>
      <th>주요 프로토콜</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Network</td>
      <td>IP</td>
    </tr>
    <tr>
      <td>Data Link</td>
      <td>Ethernet, WIFI</td>
    </tr>
    <tr>
      <td>Physical</td>
      <td>Twisted Pair</td>
    </tr>
  </tbody>
</table>

<h2 id="ip-주소">IP 주소</h2>
<p>IP 인터넷 상의 각 컴퓨는 각각의 주소를 가지고 있다. 이를 IP주소라고 한다.</p>
<ul>
  <li>서버 : 고정된 ip주소 필요하다. 사람들이 찾아간다.윛기가 바뀐다면 찾기 힘듬</li>
  <li>클라이언트 : 고정되지 않아도 된다.</li>
</ul>

<h2 id="ipc를-위한-인터페이스---소켓">IPC를 위한 인터페이스 - 소켓</h2>
<p>소켓의 인덱싱(주소 역할)하는 것은 IP 주소와 포트번호(프로세스를 구별 하기 위함)
브라우저에서 입력하는 방법 www.naver.com
실제로는 www.naver.com:80 포트는 생략하면 80으로</p>

<h3 id="어플리케이션끼리-같은-포트를-사용하는-이유">어플리케이션끼리 같은 포트를 사용하는 이유?</h3>
<p>서버 24시간 켜야하고, 주소가 일정해야 한다.
DNS는 주소만 해석한다. 포트가 다르면 포트에대한 처리를 해주어야함</p>

<h2 id="트랜스포트-계층에서-기대-되는것">트랜스포트 계층에서 기대 되는것</h2>
<ol>
  <li><code class="highlighter-rouge">데이타 무결성</code> - 이것만 가능!!!</li>
  <li>타이밍</li>
  <li>쓰루풋</li>
  <li>보안</li>
</ol>

<h2 id="httphyper-text-transfer-protocol">HTTP(Hyper Text Transfer Protocol)</h2>
<p>하이퍼텍스트? - 택스트 인데 중간에 링크들이 있음<br />
HTTP는 대부분 TCP를 사용해서 TCP 커넥션이 필요하다.<br />
HTTP는 state less이다. 상태를 기억하지 않는다.</p>

<h3 id="non-persistent-http">Non Persistent HTTP</h3>
<p>TCP연결을 설정, 상대편이 설정하면 연결완료되면 HTTP통신을 한다. 이후 TCP연결을 해제 한다. 
1개 페이지가 여러개로 구성되어 있다면 계속 TCP부터 연결을 한다.</p>

<h3 id="persistent-http">Persistent HTTP</h3>
<p>연결을 재사용 한다. 클라이언트에서 정보를 다 받았다고 판단 했을때 TCP연결 해재한다. 실제는 보통 persistent를 사용한다.</p>

<p>실제로는 한번에 리소스 여러개 요청을 보낸다.(파이프라인 방식)</p>

<h2 id="소켓-프로그레밍">소켓 프로그레밍</h2>
<p>어플리케이션 프로그램 OS가 아니다. OS에서 제공하는 서비스를 사용 OS가 제공하는 인터페이스를 사용하는것이다.
TCP/UDP에 맞게 해당하는 소켓을 사용해서 데이터를 주고 받는다.</p>

<h2 id="멀티-플랙싱과-디멀티-플랙싱">멀티 플랙싱과 디멀티 플랙싱</h2>
<p>TCP에서는 세그먼트를 주고 받는다. 이는 어플리케이션 측 데이터에 TCP헤더가 추가된것이다.</p>

<h3 id="멀티플랙싱">멀티플랙싱</h3>
<p>Sender가 어플리케이션에서 전달된 다양한 데이터를 세그먼트로 만들어줌</p>

<h3 id="디멀티-플랙싱">디멀티 플랙싱</h3>
<p>Reciver가 세그먼트에 맞게 어플리케이션 계층에 데이터를 전달</p>

<h2 id="transfer-layer의-header">Transfer layer의 Header</h2>
<p>헤더의 여러필드가 있는데 그중에서 중요한 것은 소스와 데스트네이션의 포트번호이다.
클라이언트에서 소스는 자신의 포트이고 데스트네이션은 서버의 포트이다.</p>

<h3 id="tcp의-경우">TCP의 경우</h3>
<p>TCP는 소켓을 구별한다. 소스, 데스네이션 각각의 아이피와 포트번호 4가지 중 하나라도 틀리면 다른 소켓이다.
TCP 연결지향 - 특정 연결에 대한 소켓을 만든다. 자원소모가 크다.</p>
<ul>
  <li>브로드 캐스트 : 각각 TCP연결을 한다.</li>
</ul>

<h3 id="udp의-경우">UDP의 경우</h3>
<p>UDP는 아무나 전달, 그냥 소켓으로 전달만함 
UDP는 신뢰성 보장을 하지 않는다. 하지만 트랜스포트에서 제공하는 것은 제공함</p>

<h3 id="udp-헤더-필드">UDP 헤더 필드</h3>
<p>TCP에 비해 간단하다. 
소스포트 16비트 /목적지포트 16비트/ Length(멀티플랙싱, 디멀티 플랙싱에 사용) /체크섬
체크섬으로 에러 파악, 전송하지 않고 죽이는 식</p>

<h2 id="transport에서-해주어야하는거">Transport에서 해주어야하는거</h2>
<p>멀티플랙싱과 에러채킹(에러가 발생하면 어플리케이션으로 가지 않는다.) 이는 UDP도 동일하다.</p>

<h2 id="relable-data-tranfer-protocol">Relable data tranfer protocol</h2>
<p>TCP 4가지 특징중 가장 중요한건 릴라이어블 통신 환경은 사실 불안전하다.</p>
<ol>
  <li>패킷의 유실</li>
  <li>패킷 에러</li>
</ol>

<h3 id="10-단순한-버전">1.0 단순한 버전</h3>
<p>에러와 유실이 없는 경우</p>
<ul>
  <li>sender - 그냥 보냄</li>
  <li>reciver - 그냥 받음</li>
</ul>

<h3 id="20-에러가-있는-경우">2.0 에러가 있는 경우</h3>
<ul>
  <li>Error 탐지 : 체크섬을 추가</li>
  <li>Feed back : 패킷을 받을때마다 Ack/Nak
(Negative Ack)를 보냄</li>
  <li>재전송 : Nak받으면 재전송
Sender - 채크섬을 추가해서 보냄
Reciver - 체크섬확인 후 애러여부를 송신
피드백도 체크섬이 필요 피드백도 에러가 있을수 있다.
피드백이 망가진경우 다시 보낸다.</li>
</ul>

<h3 id="21-리시버가-중복데이터를-받으면-다시보낸건지-알수-없다">2.1 리시버가 중복데이터를 받으면 다시보낸건지 알수 없다.</h3>
<p>구별이 필요 -&gt; 패킷에 번호를 붙인다. -&gt; sequence number
sqeunce number 붙이는 법
header붙인다. - 부가정보니까
순서대로 붙인다. - 크기가 무한대가 됨 하지만 ㄴ헤더크기는 작을 수록 좋다. 최소한의 필드만 있어야 한다.
2개면 충분 - 0, 1 
0 받았으면 1기다림, 1받았으면 0기다림</p>

<h3 id="22-nak를-없앤-프로토콜">2.2 NAK를 없앤 프로토콜</h3>
<p>ACK에 가장 마지막에 받은 sequnce를 보낸다.
ACK번호가 이전과 같으면 애러</p>

<h3 id="30-메세지-유실여부까지-추가">3.0 메세지 유실여부까지 추가</h3>
<ul>
  <li>유실 - 유실되면 ACK가 안옴 <br />
타이머를 넣는다. 
메세지를 보내고 타이머를 돌림<br />
얼마나 기다려야 하는가?</li>
</ul>

<h4 id="trade-off">Trade off</h4>
<p>시간이 짧음 - 실제 유실이 일어난경우 복구가 빠르다. 중복된걸 받을수 있다. - 지연됬는데도 유실로 처리되어서, 네트워크 오버헤드
시간이 길다 - 유실에 대한 반응이 늦다. 복구가 느림</p>

<h3 id="성능-측정">성능 측정</h3>
<p>Utilization - 전체 시간중에 sender가 메시지를 보내는 비율</p>

<h2 id="tcp-header">TCP Header</h2>
<p>에러,손실처리, 나머지 기능을 = 처리하기 위한것을 처리</p>

<h2 id="파이프라이닝">파이프라이닝</h2>
<p>실제는 하니씩 보내는게 아니라 한꺼번에 보낸다. 하나씩 보내는것 보다. Utilization이 높아짐</p>
<ol>
  <li>Go-Back-N</li>
  <li>Selected Repeat</li>
</ol>

<h3 id="go-back-n">GO-Back-N</h3>
<ul>
  <li>window : 한번에 얼마 만큼 보낼것인가?</li>
  <li>Ack(n) : n개까지 받았다.</li>
  <li>타이머 : 패킷마다 타이머가 존재, 타임아웃되면 해당 패킷 포함해서 이후는 전부 재전송</li>
</ul>

<div class="highlighter-rouge"><pre class="highlight"><code>1 2 3 4 5 x 7 8 9(6 이후 버림)
          6 7 8 9
</code></pre>
</div>
<p>샌더는 윈도우에 있는 패킷은 버퍼에 저장-리시버가 받았는지를 모름</p>

<h3 id="selected-repeat">Selected Repeat</h3>
<p>없어진 것만 재전송 
Ack(n) : n번 패킷을 받았다. 순서가 맞지 않아도 버퍼에 저장한다.</p>
<div class="highlighter-rouge"><pre class="highlight"><code>1234 -&gt; 1 34(버퍼에 저장)
     &lt;- 1, 3, 4 ACK
   2 -&gt; 1234
     &lt;- 2 ACK
</code></pre>
</div>
<p>모든 패킷에 타이머를? 윈도우의 크기가 크면 문제가 발생</p>

<h3 id="sequnce-number">Sequnce number</h3>
<p>최소한의 sequence number가 효율적이므로 재사용한다.
N을 윈도우 사이즈라고 한다면,
짧으면 N+1개 -&gt; 0번이 유실되면 다음에 들어오는 0이 다음껀지 이번껀지 혼동 될수있다.
범위를 늘린다. -&gt; 늘리면 비효율 ㅠ
<code class="highlighter-rouge">구별이 되는 최소의 범위를 찾기</code> 
약 2*N개(시스템마다 다를 수 있다.)</p>

<h2 id="tcp에서-파이프-라인-구현">TCP에서 파이프 라인 구현</h2>
<p>2가지 방법의 장점을 취합해서 구현한다.
윈도우 마다 타이머를 설정, GBN의 ACK를 사용</p>


  </div>

  <div class="date">
    Written on October  7, 2017
  </div>

  
</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          



<a href="https://github.com/changmin-dev"><i class="svg-icon github"></i></a>








        </footer>
      </div>
    </div>

    

  </body>
</html>
