<!DOCTYPE html>
<html>
  <head>
    <title>2017년 9월 1일 TIL – Twibeat – 잊어 버리지 않기 위해서</title>

        <meta charset="utf-8" />
    <meta content='text/html; charset=utf-8' http-equiv='Content-Type'>
    <meta http-equiv='X-UA-Compatible' content='IE=edge'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>

    
    <meta name="description" content="운영체제
역시 정리 자료보다는 책으로 보는게 확실히 좋은거 같다.

" />
    <meta property="og:description" content="운영체제
역시 정리 자료보다는 책으로 보는게 확실히 좋은거 같다.

" />
    
    <meta name="author" content="Twibeat" />

    
    <meta property="og:title" content="2017년 9월 1일 TIL" />
    <meta property="twitter:title" content="2017년 9월 1일 TIL" />
    

    <!--[if lt IE 9]>
      <script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <link rel="stylesheet" type="text/css" href="/style.css" />
    <link rel="alternate" type="application/rss+xml" title="Twibeat - 잊어 버리지 않기 위해서" href="/feed.xml" />

    <!-- Created with Jekyll Now - http://github.com/barryclark/jekyll-now -->
  </head>

  <body>
    <div class="wrapper-masthead">
      <div class="container">
        <header class="masthead clearfix">
          <a href="/" class="site-avatar"><img src="https://github.com/identicons/changmin-dev.png" /></a>

          <div class="site-info">
            <h1 class="site-name"><a href="/">Twibeat</a></h1>
            <p class="site-description">잊어 버리지 않기 위해서</p>
          </div>

          <nav>
            <a href="/">Blog</a>
            <a href="/TIL">TIL</a>
            <a href="/about">About</a>
          </nav>
        </header>
      </div>
    </div>

    <div id="main" role="main" class="container">
      <article class="post">
  <h1>2017년 9월 1일 TIL</h1>

  <div class="entry">
    <h1 id="운영체제">운영체제</h1>
<p>역시 정리 자료보다는 책으로 보는게 확실히 좋은거 같다.</p>

<h2 id="프로세스-계속">프로세스 계속</h2>

<h3 id="스케줄러">스케줄러</h3>
<p>각 큐마다 다음 차례의 프로세스를 결정하여 주는 스케줄러가 존재한다.</p>
<ul>
  <li>장기 스케줄러(작업 스케줄러)<br />
다중 프로그램의 정도(메모리에 있는 프로세스들의 수)제어, 단기 스케줄러보다 적은 수행 빈도, 없는 운영체제들도 있음(윈도우, 유닉스)</li>
  <li>단기 스케줄러(CPU 스케줄러)<br />
새로운 프로세스를 선택, 자주 실행됨</li>
  <li>중기 스케줄러<br />
일부를 메모리 밖으로 보냄, 이후에 다시 가져와서 중단 시점부터 실항하게 함(swapping)</li>
</ul>

<h3 id="문맥-전환">문맥 전환</h3>
<p>실행 중인 프로세스의 상태를 보관하고 새로운 프로세스의 상태를 CPU에 적재하는 과정을 말한다.</p>

<h3 id="프로세스-연산">프로세스 연산</h3>
<h4 id="프로세스-생성">프로세스 생성</h4>
<p>프로세스는 수행중에 여러 프로 세스를 생성할 수 있다. 이렇게 생성된 프로세스를 자식 프로세스가 된다. 생성한 프로세스는 부모 프로세스라고 한다. 자식프로세스는 필요한 자원을 운영체제로 부터 받거나 부모 프로세스로 부터 받을 수 있다.</p>

<h4 id="부모-프로세스와-자식-프로세스를-실행시키는-방법">부모 프로세스와 자식 프로세스를 실행시키는 방법</h4>
<ol>
  <li>부모와 자식을 동시에 실행</li>
  <li>부모가 자식(전부 혹은 일부)이 실행을 종료 할 때 까지 기다린다.</li>
</ol>

<h4 id="새로운-프로세스들의-주소-공간">새로운 프로세스들의 주소 공간</h4>
<ol>
  <li>자식 프로세스는 부모 프로세의 복사본인 경우(유닉스의 fork)</li>
  <li>자식 프로세스가 자신에게 적재될 새로운 프로그램을 가지는 경우(윈도우즈의 CreateProcess)</li>
</ol>

<h4 id="프로세스-종료">프로세스 종료</h4>
<p>프로세스의 코드의 마지막 문장을 실행하면 exit()시스템 콜을 함으로써 프로세스는 종료한다.</p>

<h4 id="부모가-자식들-중-하나를-종료하는-이유들">부모가 자식들 중 하나를 종료하는 이유들</h4>
<ol>
  <li>자식이 자신에게 할당된 자원을 초과하여서 사용할 때</li>
  <li>자식에게 할당된 태스크가 더이상 필요 없을 때</li>
  <li>부모가 exit을 하는경우. 운영체제에서 부모가 exit하였을때 자식이 계속 실행되는 것을 허용하지 않는 경우</li>
</ol>

<p>프로세스가 종료하면, 자원은 운영체제에 의해 반환되지만, 부모 프로세스가 wait()호출을 하지 않으면 프로세스 테이블의 해당 항목은 남아 있게된다. 여기서 2가지 상황이 야기 된다.</p>
<ol>
  <li>좀비 프로세스 : 종료 되었지만 부모 프로세스가 wait()호출을 하지 않는 경우</li>
  <li>고아 프로세스 : 부모프로세스가 wait() 호출을 하지 않고 종료한 경우</li>
</ol>

<h3 id="프로세스간-통신">프로세스간 통신</h3>
<p>운영체제에서 실행되는 병행 프로세스들은 독립적이거나 협력적인 프로세스이다.</p>

<h4 id="프로세스가-협력-하는-이유">프로세스가 협력 하는 이유</h4>
<ol>
  <li>정보공유 - 동일 한 정보에 접근해야 하는 경우</li>
  <li>계산 가속화 - 특정 작업을 분산해서 처리하는 경우</li>
  <li>모듈성 - 시스템을 별로의 프로세스 혹은 스레드를 나누어 시스템을 구성하는 경우</li>
  <li>편의성 - 개별 사용자들이 한 순간에 작업할 많은 태스크를 가질 수도 있다.</li>
</ol>

<h4 id="협력의-방법-2가지가-같이-사용-될-수-있음">협력의 방법 (2가지가 같이 사용 될 수 있음)</h4>
<ol>
  <li>
    <p>공유 메모리 : 통신하는 프로세스가 공유메모리 영역을 구축해야됨, 생산자 소비자 문제에서 버퍼 같은경우</p>
  </li>
  <li>
    <p>메시지 전달 : send와 recieve연산, 통션 연결 설정이 필요</p>
    <ul>
      <li>직접 통신 : 연결은 자동으로 구축 상대의 identity만 알면 된다. 연결은 두 프로세스 사이에만, 각 쌍 사이이에는 하나의 연결이 존재해야함</li>
    </ul>
  </li>
</ol>

<ul>
  <li>
    <p>간접 통신 : 메일박스(메시지가 저장되는 객체 식별을 위한 id를 갖는다) 혹은 포트로 송신, 한 쌍의 프로세스들 사이의 연결은 이플 프로세스가 공유 메일 박스를 가질 때만 구축된다. 연결은 두 개 이상의 프로세스들과 연관 될 수 있다. 통신하고 있는 각 프로세스들 사이에는 다수의 서로 다른 연결이 존재할 수 있고, 각 연결은 하나의 메일 박스에 대응된다.</p>
  </li>
  <li>동기화 :
    <ol>
      <li>봉쇄 형 : 동기식, 대기하는 경우</li>
      <li>비봉쇄 형 :  비동기 식, 대기 하지 않는 경우</li>
    </ol>
  </li>
  <li>버퍼링 : 통신하는 프로세스들에 의해 교환 되는 메시지는 임시 큐에 들어 있다.
    <ol>
      <li>무용량(zero capacity) : 송신자는 메시지가 수신될떄까지 대기</li>
      <li>유한 용량 : 버퍼가 비어있지 않은 경우만 대기</li>
      <li>무한 용량 : 송신자는 대기 하지 않음</li>
    </ol>
  </li>
</ul>

<h2 id="쓰레드">쓰레드</h2>
<p>쓰래드 : 경량 프로세스, 프로세스와 같이 cpu작업 단위가 된다.
다중 쓰래드 시스템
프로세스를 생성하는 것은 비용이 많이드는 방법, 스레드를 사용하는 것이 효율 적인 방법이다.</p>

<h3 id="다중-스레드의-장점">다중 스레드의 장점</h3>
<ol>
  <li>응답성 : 일부가 대기 하더라도 나머지 부분은 실행된다.</li>
  <li>자원공유 : 같은 프로세스의 스레드들은 자원들과 메모리를 공유한다.</li>
  <li>경제정: 프로세스보다 경제적이다. 스레드에 비해 프로세스는 생성하는데 30배, 문맥교환에 5배가 걸린다.</li>
  <li>규모 적응성 : 각각의 스레드가 다른 처리기에서 병렬로 수행가능하다.</li>
</ol>

<h3 id="다중코어-프로그래밍">다중코어 프로그래밍</h3>
<p>코어는 한번에 하나의 스레드만 실행가능하다. 다중 코어를 사용함으로 써 스레드들이 병렬적으로 실행가능하게 할 수 있다.</p>
<ul>
  <li>병행 실행 : 스케줄링 때문에 병렬 실행 처럼 보이게 된다. 병렬 실행과 구분 해야함</li>
</ul>

<h4 id="다중-코어-시스템-구현을-위한-과제">다중 코어 시스템 구현을 위한 과제</h4>
<ol>
  <li>태스크인식 : 테스크를 나눌수 있는 영역찾기</li>
  <li>밸런스 : 나누어진 영역이 균등하게 실행되어야 한다.</li>
  <li>데이터 분리 : 데이터도 테스크 처럼 개별 코어에 사용하도록 분리해야 한다.</li>
  <li>데이터 종속성 : 둘이상의 테스크사이에 종속성이 없는지 검토</li>
  <li>테스팅 및 디버깅 : 단일 스레드보다 어려움</li>
</ol>

<h4 id="병렬-수행-유형">병렬 수행 유형</h4>
<ul>
  <li>데이터 병렬 실행 : 동일한 데이터를 다수의 코어에 분배</li>
  <li>테스크 병렬 실행 : 각 스레드를 다수의 코어에 분배</li>
</ul>

<h3 id="다중-쓰레드-모델">다중 쓰레드 모델</h3>
<ol>
  <li>다대일 모델 :
여러개의 사용자 스레드와 하나의 커널스레드, 한 유저 스레드가 blocking 시스템 콜을 하면 다른 사용자 스레드는 커널 스레드 사용을 위해 대기해야한다.</li>
  <li>일대일 모델 : 사용자 스레드 1개에 커널스레드 1개를 매핑하는 방법, 사용자 스레드를 생성하면 커넬 스레드도 같이 생성해야하기 때문에 비용이 크다.</li>
  <li>다대다 모델 : 사용자 스레드 수 &lt;= 커널스레드</li>
</ol>

<h3 id="명시적-스레딩">명시적 스레딩</h3>
<p>라이브러리 api를 사용해는 방법  <br />
유닉스 ptread, 윈도우 스레드</p>

<h3 id="암묵적-스레딩">암묵적 스레딩</h3>
<p>컴파일 시간이나 런타임에 스레드 생성에 대한 책임을 지게 하는 방법</p>

<h4 id="스레드-풀">스레드 풀</h4>
<p>프로세스가 실행 될때 일정한 수의 스레드를 만들어두고 요청이 들어 올때마다 할당하는 방법, 필요 할때 생성하는 것보다 빠르고 스레드 수를 제한하는 방법으로 사용 될 수 있다.</p>


  </div>

  <div class="date">
    Written on September  1, 2017
  </div>

  
</article>

    </div>

    <div class="wrapper-footer">
      <div class="container">
        <footer class="footer">
          



<a href="https://github.com/changmin-dev"><i class="svg-icon github"></i></a>








        </footer>
      </div>
    </div>

    

  </body>
</html>
