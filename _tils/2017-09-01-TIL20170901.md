---
layout: post
title: 2017년 9월 1일 TIL
---

# 운영체제
역시 정리 자료보다는 책으로 보는게 확실히 좋은거 같다.

## 프로세스 계속

### 스케줄러
각 큐마다 다음 차례의 프로세스를 결정하여 주는 스케줄러가 존재한다.
- 장기 스케줄러(작업 스케줄러)  
다중 프로그램의 정도(메모리에 있는 프로세스들의 수)제어, 단기 스케줄러보다 적은 수행 빈도, 없는 운영체제들도 있음(윈도우, 유닉스)
- 단기 스케줄러(CPU 스케줄러)  
새로운 프로세스를 선택, 자주 실행됨
- 중기 스케줄러  
일부를 메모리 밖으로 보냄, 이후에 다시 가져와서 중단 시점부터 실항하게 함(swapping)

### 문맥 전환
실행 중인 프로세스의 상태를 보관하고 새로운 프로세스의 상태를 CPU에 적재하는 과정을 말한다. 

### 프로세스 연산
#### 프로세스 생성 
프로세스는 수행중에 여러 프로 세스를 생성할 수 있다. 이렇게 생성된 프로세스를 자식 프로세스가 된다. 생성한 프로세스는 부모 프로세스라고 한다. 자식프로세스는 필요한 자원을 운영체제로 부터 받거나 부모 프로세스로 부터 받을 수 있다.   

#### 부모 프로세스와 자식 프로세스를 실행시키는 방법
1. 부모와 자식을 동시에 실행 
2. 부모가 자식(전부 혹은 일부)이 실행을 종료 할 때 까지 기다린다.

#### 새로운 프로세스들의 주소 공간 
1. 자식 프로세스는 부모 프로세의 복사본인 경우(유닉스의 fork) 
2. 자식 프로세스가 자신에게 적재될 새로운 프로그램을 가지는 경우(윈도우즈의 CreateProcess) 

#### 프로세스 종료
프로세스의 코드의 마지막 문장을 실행하면 exit()시스템 콜을 함으로써 프로세스는 종료한다.

#### 부모가 자식들 중 하나를 종료하는 이유들
1. 자식이 자신에게 할당된 자원을 초과하여서 사용할 때
2. 자식에게 할당된 태스크가 더이상 필요 없을 때
3. 부모가 exit을 하는경우. 운영체제에서 부모가 exit하였을때 자식이 계속 실행되는 것을 허용하지 않는 경우

프로세스가 종료하면, 자원은 운영체제에 의해 반환되지만, 부모 프로세스가 wait()호출을 하지 않으면 프로세스 테이블의 해당 항목은 남아 있게된다. 여기서 2가지 상황이 야기 된다.
1. 좀비 프로세스 : 종료 되었지만 부모 프로세스가 wait()호출을 하지 않는 경우 
2. 고아 프로세스 : 부모프로세스가 wait() 호출을 하지 않고 종료한 경우

### 프로세스간 통신 
운영체제에서 실행되는 병행 프로세스들은 독립적이거나 협력적인 프로세스이다.

#### 프로세스가 협력 하는 이유 
1. 정보공유 - 동일 한 정보에 접근해야 하는 경우 
2. 계산 가속화 - 특정 작업을 분산해서 처리하는 경우 
3. 모듈성 - 시스템을 별로의 프로세스 혹은 스레드를 나누어 시스템을 구성하는 경우 
4. 편의성 - 개별 사용자들이 한 순간에 작업할 많은 태스크를 가질 수도 있다.

#### 협력의 방법 (2가지가 같이 사용 될 수 있음)
1. 공유 메모리 : 통신하는 프로세스가 공유메모리 영역을 구축해야됨, 생산자 소비자 문제에서 버퍼 같은경우 

2. 메시지 전달 : send와 recieve연산, 통션 연결 설정이 필요
- 직접 통신 : 연결은 자동으로 구축 상대의 identity만 알면 된다. 연결은 두 프로세스 사이에만, 각 쌍 사이이에는 하나의 연결이 존재해야함

- 간접 통신 : 메일박스(메시지가 저장되는 객체 식별을 위한 id를 갖는다) 혹은 포트로 송신, 한 쌍의 프로세스들 사이의 연결은 이플 프로세스가 공유 메일 박스를 가질 때만 구축된다. 연결은 두 개 이상의 프로세스들과 연관 될 수 있다. 통신하고 있는 각 프로세스들 사이에는 다수의 서로 다른 연결이 존재할 수 있고, 각 연결은 하나의 메일 박스에 대응된다.

- 동기화 :
1. 봉쇄 형 : 동기식, 대기하는 경우 
2. 비봉쇄 형 :  비동기 식, 대기 하지 않는 경우 

- 버퍼링 : 통신하는 프로세스들에 의해 교환 되는 메시지는 임시 큐에 들어 있다.  
1. 무용량(zero capacity) : 송신자는 메시지가 수신될떄까지 대기
2. 유한 용량 : 버퍼가 비어있지 않은 경우만 대기 
3. 무한 용량 : 송신자는 대기 하지 않음


## 쓰레드
쓰래드 : 경량 프로세스, 프로세스와 같이 cpu작업 단위가 된다.
다중 쓰래드 시스템
프로세스를 생성하는 것은 비용이 많이드는 방법, 스레드를 사용하는 것이 효율 적인 방법이다. 

### 다중 스레드의 장점
1. 응답성 : 일부가 대기 하더라도 나머지 부분은 실행된다.
2. 자원공유 : 같은 프로세스의 스레드들은 자원들과 메모리를 공유한다.
3. 경제정: 프로세스보다 경제적이다. 스레드에 비해 프로세스는 생성하는데 30배, 문맥교환에 5배가 걸린다.
4. 규모 적응성 : 각각의 스레드가 다른 처리기에서 병렬로 수행가능하다.

### 다중코어 프로그래밍 
코어는 한번에 하나의 스레드만 실행가능하다. 다중 코어를 사용함으로 써 스레드들이 병렬적으로 실행가능하게 할 수 있다.  
 - 병행 실행 : 스케줄링 때문에 병렬 실행 처럼 보이게 된다. 병렬 실행과 구분 해야함 

#### 다중 코어 시스템 구현을 위한 과제 
1. 태스크인식 : 테스크를 나눌수 있는 영역찾기 
2. 밸런스 : 나누어진 영역이 균등하게 실행되어야 한다.
3. 데이터 분리 : 데이터도 테스크 처럼 개별 코어에 사용하도록 분리해야 한다.
4. 데이터 종속성 : 둘이상의 테스크사이에 종속성이 없는지 검토 
5. 테스팅 및 디버깅 : 단일 스레드보다 어려움

#### 병렬 수행 유형 
- 데이터 병렬 실행 : 동일한 데이터를 다수의 코어에 분배
- 테스크 병렬 실행 : 각 스레드를 다수의 코어에 분배 

### 다중 쓰레드 모델 
1. 다대일 모델 :
여러개의 사용자 스레드와 하나의 커널스레드, 한 유저 스레드가 blocking 시스템 콜을 하면 다른 사용자 스레드는 커널 스레드 사용을 위해 대기해야한다. 
2. 일대일 모델 : 사용자 스레드 1개에 커널스레드 1개를 매핑하는 방법, 사용자 스레드를 생성하면 커넬 스레드도 같이 생성해야하기 때문에 비용이 크다.
3. 다대다 모델 : 사용자 스레드 수 <= 커널스레드

### 명시적 스레딩
라이브러리 api를 사용해는 방법    
유닉스 ptread, 윈도우 스레드

### 암묵적 스레딩 
컴파일 시간이나 런타임에 스레드 생성에 대한 책임을 지게 하는 방법 

#### 스레드 풀 
프로세스가 실행 될때 일정한 수의 스레드를 만들어두고 요청이 들어 올때마다 할당하는 방법, 필요 할때 생성하는 것보다 빠르고 스레드 수를 제한하는 방법으로 사용 될 수 있다.

