---
layout: post
title: 2017년 9월 3일 TIL
---
TIL을 계속 쓰니까 왠지 문법이 많이 틀렸을꺼 같은 생각이 든다. 
## 프로세스 동기화
### 경쟁 조건 
여러개의 프로세스가 동일한 자료에 접근하여 조작하고 실행결과가 접근이 발생한 특정 순서에 의존하는 상황을 `경쟁 조건`이라고 한다.

### 임계 영역
`임계영역`은 코드에서 다른 프로세스와 공동으로 사용하는 영역(변수, 테이블, 파일등을 변경하는 영역)이다. 각 프로세스는 임계 영역에 들어가기위해 요청을 해야하는데 이 코드 부분을 `진입영역`이라고 한다. 이후에 다른 프로세들이 진입할 수 있게 해주어야 하는데 이 코드 부분을 `출구영역`이라고 한다. 

### 임계 영역 해결을 위한 3가지 요구 조건 
1. 상호배제 : 한 프로세스가 임계영역에서 실행되고 있다면 다른 프로세스는 자신의 임계영역에서 실행 될 수 없다.
2. 진행 : 임계 구역을 실행하는 프로세스가 없을 때 임계 구역에 진입하려는 프로세스가 생긴다면, 진입 순서는 이들에 의해서만 결정 되어야 한다.   
3. 한정된 대기 : 한 프로세스가 자기의 임계영역에 진입하려는 요청을 한 후 부터 그 요청이 허용 되기까지 다른 프로세스가 자기의 임계 영역에 진입 할 수 있는 횟수에는 제한이 있어야 한다. (대기 시간이 한없이 길어지면 안된다.)

### 운영체제(커널)에서 임계 영역을 다루기위한 접근법
1. 선점형 커널 : 프로세스가 커널모드에서 실행되는 동안 선점하게함 
2. 비선점형 커널 : 커널모드에 들어 갈 수 있는 프로세스는 1개 라서 경쟁 조건이 없다.

## 임계영역을 문제 해결을 위한 방법들 
### 피터슨의 방법
병렬로 실행된다고 생각해야 이해가 쉽다.
load, store 명령어 때문에 문제가 발생할 여지가 있다고 한다.
```
//임계 영역으로 진입할 순번
int turn;
// 임계 영역으로 진입할 준비가 되었는지를 나타내는 배열 
boolean flag[2];//2개의 경우에만 
while(true){
    flag[i] = TRUE;
    turn = j;
    while(flag[j] && turn == j);
    //임계 영역
    flag[i] = FALSE;//
    //나머지 영역
}
```

### 동기화 하드웨어
하드웨어 적으로 록을 사용한다. 공유변수가 변경되는 동안 인터럽트를 금지 시키는 방법으로 구현한다. 혹은 현대적인 하드웨어에서는 데이터 원자적으로 접근하는 명령어를 제공한다.

### 세마포어
책이 공룡책 자바 버전이다 보니 wait(), signal()이 아니라 조금 다르다. 세마포어는 S에서 value로 표현 됨

기본 적인 방식
```
//P연산 이라고도 불린다.
acquire(){
    while(value <= 0);
    value--;
}
//V연산이라고도 불린다.
release(){
    value++;
}
```
위의 방식은 Busy wating 문제(자원이 없으면 계속 While문 반복)가 있다.  

개선된 방법. 자원이 없는 경우 프로세스를 리스트에 넣고 대기하도록한다.
```
acquire(){
    value--;
    if(value < 0){
        해당 프로세스를 리스트에 넣는다();
        block();//호출한 프로세스를 대기 시킴
    }
}

release(){
    value++;
    if(value <= 0){
        리스트로부터 하나의 프로세스를 꺼낸다();
        wakeup(P);//프로세스 P를 재개 시킴
    }
}
```

### 모니터 
프로그래머가 세마포어를 잘못 사용하면 다양한 유형의 오류가 생길 수 있다. 이를 해결하기 위한 방법 중 하나가 모니터이다.

#### 자바의 모니터
자바에서는 synchronized와 wait(), notify()를 이용해서 동기화를 구현한다.  
synchronized : synchronized가 선언된 부분은 실행시 록을 소유하게 되고 다른 스레드에서 접근 할수가 없다. 접근할 경우 록이 해제되도록 기다리는 `진입 집합(entry set)`에 들어가게 된다.  
wait() : 스레드에게 호출되면 스레드는 객체에 대한 록을 방출하고 Blocking 상태가 된다. 그리고 `대기 집합(wait set)`에 들어가게 된다.  
notify() : 대기 집합의 스레드 중에서 임의 스레드를 진입집합으로 옮기고 Blocking 상태에서 Runnable상태로 바꾼다.

## 교착상태(Dead lock)
프로세스(스레드)가 대기상태에서 벗어날수 없는 상황. 요청한 자원을 다른 프로세스가 점유하고 있고 점유하고 있는 프로세스도 대기 상태라면 교착상태가 될 수 있다.

### 교착 상태의 조건
조건중 하나만 만족하지 않는다면 교착상태에 빠지지 않는다.
1. 상호배제 
2. 점유하며 대기 
3. 비선점
4. 순환대기(circular wait)
