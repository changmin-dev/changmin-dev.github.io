---
layout: post
title: 8월 29일 TIL
---
## 클린 소프트 웨어
일단 가장 급한 객체지향 부분만 보기로 했다.  

### 설계의 악취
1. 경직성 : 약간의 변경을 하기 위해서도  시스템의 다른 많은 부분까지 변경 해야되서 시스템 변경이 어려움
2. 취약성 : 변경을 하면 시스템에서 그 부분과 개념적으로 아무런 관련이 없는 부분이 망가짐 
3. 부동성 : 시스템에서 다른 시스템에서 재사용 할 수 있는 부분을 분리해 내기 어려움
4. 점착성 : 설계를 변경 하는 방법이 설계를 유지하는 방법보다 쉬워지는 경우(설계의 점착성 높음), 개발이 느리고 비효율 적일때(환경의 점착성- 설계를 무시하고 빠르게 가는것만 고려 할수 있다.)
5. 불필요한 복잡성 : 직접적인 효용이 전혀 없는 기반 구조가 설계에 포함되어 있는 경우. 앞으로 일어날지도 모르는 일을 과도하게 준비함으로 발생할 수 있다.
6. 불피료한 반복 : 단일 추상 개념으로 통합 할수 있는 반복적인 구조가 설계에 포함되어 있다.
7. 불투명성 : 이해하기 어렵고 의도를 알수가 없음 

### 애자일 설계
앞의 안좋은 예제를 보고 애자일 버전을 보면 카타르시스가 느껴진다.

Copy프로그램
```
void Copy(){
    int c;
    while((c = readKeyboard()) != EOF))
        WritePrinter(c);
}
```
테이프로 입력을 받아야한다는 추가 요구 사항을 반영해 플래그를 추가한다. 
```
bool printFlag = false;

void Copy(){
    int c;
    while((c = (printFlag ? readTape() : readKeyboard()) != EOF))
        writePrinter)
}
```
이런식으로 하면 요구 사항이 추가 될때 마다 Flag는 늘어 갈 것이고 소스 코드는 복잡해 질것이다.


애자일 설계 예
```
class Reader{
    public: virtual int read();
}
class KeyboardReader : public Reader{
    public : virtual read(){
        return readKeyboard();
    }
}
KeyboardReader GdefaultReader;

void Copy(Reader & reader = GdefaultReader){
    int c;
    while((c = reader.read() != EOF))
        writePrinter(c);
}

```
새로 Reader 클래스를 만들어 주고 기존의 소스 로직 변경이 없도록 한다. 

## 자료구조 
자료구조 시간에 뒷부분에 나오는 그래프는 다른 자료구조에 비해서 복잡하고 학기말이라는 특수성때문에 소흘하게 다루어 진 기억이 있어 그래프를 먼저 공부하기로 했다.

### 그래프 기본
개념이 많다. 너무 많다. 되는 대로 쓰다보니 섞이고 가독성도 좋지 않다.
- 간선(Edge)과 정점(vertex)로 구성
- 방향 간선(Directed Edge) : 방향이 있는 간선 u -> v
- (Undirected Edge) : 방향이 없는 간선 u - v
- 방향 그래프, 무방향 그래프 : 모든 간선이 방향, 모든 간선이 무방향 일때 
- 두 정점을 포함하는 경로가 존재 할때 이 그래프를 연결 되었다고 한다. 
- 어떤 그래프가 연결 되지 않았다면, 연결된 요소들의 집합으로 이루어져 있다.
- DAG(Directed Asyclic Graph) : 싸이클이 없는 방향그래프
- forest는 트리들의 분리 집합이다.
- 신장트리(Spanning Tree) : 모든 정점을 포함하는 트리
- 연결된 그래프의 신장트리는 그래프 그래프의 모든 정점을 포함한 하나의 트리이다.
- 신장 숲(Spanning )
- 어떤 간선이 두 정점을 연결 하면 `인접`한다고 한다.
- 자기 루프(Self Loop) : 간선이 하나의 정점으로 연결되는 경우 u -> u 형태
- 병렬 : 두 간선이 같은 정점 쌍을 연결
- 정점의 차수 : 그 점에 부속된 간선의 개수 이다.
- 경로(Path) : 인접한 정점들의 순열이다. 
- 단순 경로 : 반복되는 정점이 없는 경우
- 사이클(Cycle) : 시작점과 끝점이 같은 경로가 되는 경우
- 사이클이 없는 그래프는 `트리`라고 한다.
- 가중치 그래프는 가중치가 각 간선에 할당된다. 
- 완전 그래프는 모든 간선이 존재하는 그래프이다. 
- 간선이 상대 적으로 적은 그래프를 희소 그래프라고 한다. 반대를 조밀 그래프라고 한다.
- 방향 가중치 그래프는 네트워크 라고도 불린다.
- 이분 그래프는 정점들이 두집합으로 나눠지고 모든 간선들이 한집합의 정점들과 다른 집합의 정점들을 연결하는 그래프이다.
- 주어진 그래프에서 간선이 가능한 범위는 0 ~ 정점의 개수 *(정점의 개수 -1)/2 이다. 모든 정점이 다른 정점에 연결 될수 있기 때문이다.

### 구현하기 
- Array구현  
- 인접리스트 구현 : 
    이미 만든 링크드 리스트를 사용했는데 몇까지 함수가 추가되었다. 나중에는 노드가 가지는 데이터는 제너릭으로 바뀌게 되었다. 
- 인접 집합 -> 이건 나중에 
 
## 참고
클린 소프트 웨어  
다양한 예제로 학습하는 데이터 구조와 알고리즘







